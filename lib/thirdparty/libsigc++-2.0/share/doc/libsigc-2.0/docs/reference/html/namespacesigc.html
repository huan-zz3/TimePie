<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libsigc++ 2.0: sigc Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.5.1 -->
<h1>sigc Namespace Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__functor.html">adaptor_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor into an adaptor type.  <a href="structsigc_1_1adaptor__functor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__trait_3_01T__functor_00_01true_01_4.html">adaptor_trait&lt;T_functor, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trait that specifies what is the adaptor version of a functor type.  <a href="structsigc_1_1adaptor__trait_3_01T__functor_00_01true_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__trait_3_01T__functor_00_01false_01_4.html">adaptor_trait&lt;T_functor, false&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trait that specifies what is the adaptor version of a functor type.  <a href="structsigc_1_1adaptor__trait_3_01T__functor_00_01false_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adapts.html">adapts</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base type for adaptors.  <a href="structsigc_1_1adapts.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_010_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;0, T_functor, T_bound, nil, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor.  <a href="structsigc_1_1bind__functor_3_010_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_011_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;1, T_functor, T_bound, nil, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor.  <a href="structsigc_1_1bind__functor_3_011_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_012_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;2, T_functor, T_bound, nil, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor.  <a href="structsigc_1_1bind__functor_3_012_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_013_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;3, T_functor, T_bound, nil, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor.  <a href="structsigc_1_1bind__functor_3_013_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_014_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;4, T_functor, T_bound, nil, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor.  <a href="structsigc_1_1bind__functor_3_014_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_015_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;5, T_functor, T_bound, nil, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor.  <a href="structsigc_1_1bind__functor_3_015_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_016_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;6, T_functor, T_bound, nil, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor.  <a href="structsigc_1_1bind__functor_3_016_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;-1, T_functor, T_type1, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 1 argument(s) to the wrapped functor.  <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, nil, nil, nil, nil, nil &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 2 argument(s) to the wrapped functor.  <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01n6d14effad731c8dfead9984e87967108.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, nil, nil, nil, nil &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 3 argument(s) to the wrapped functor.  <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01n6d14effad731c8dfead9984e87967108.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T8abd615cc403946700f41917bb90042c.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, nil, nil, nil &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 4 argument(s) to the wrapped functor.  <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T8abd615cc403946700f41917bb90042c.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01Tf230465d8da8d21a2da815d7eb05b413.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, nil, nil &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 5 argument(s) to the wrapped functor.  <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01Tf230465d8da8d21a2da815d7eb05b413.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T5d526f12c92849dac4a70f282eec9dc2.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, nil &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 6 argument(s) to the wrapped functor.  <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T5d526f12c92849dac4a70f282eec9dc2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T1564029be5092b4f54029884f8072971.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that binds 7 argument(s) to the wrapped functor.  <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T1564029be5092b4f54029884f8072971.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that fixes the return value of the wrapped functor.  <a href="structsigc_1_1bind__return__functor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A bound_argument&lt;Foo&gt; object stores a bound (for instance, with <a class="el" href="group__bind.html#g2148290d2cf9c1961ec157a085badd5a">sigc::bind()</a>, or <a class="el" href="group__bind.html#g8a001b0bb588d2ac1af712781b89dc8a">sigc::bind_return()</a>) argument.  <a href="classsigc_1_1bound__argument.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument_3_01reference__wrapper_3_01T__wrapped_01_4_01_4.html">bound_argument&lt;reference_wrapper&lt;T_wrapped&gt;&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a> object for a bound argument that is passed by <a class="el" href="group__bind.html#g2148290d2cf9c1961ec157a085badd5a">bind()</a> or returned by <a class="el" href="group__bind.html#g8a001b0bb588d2ac1af712781b89dc8a">bind_return()</a> by reference, specialized for reference_wrapper&lt;&gt; types.  <a href="classsigc_1_1bound__argument_3_01reference__wrapper_3_01T__wrapped_01_4_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument_3_01const__reference__wrapper_3_01T__wrapped_01_4_01_4.html">bound_argument&lt;const_reference_wrapper&lt;T_wrapped&gt;&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a> object for a bound argument that is passed by <a class="el" href="group__bind.html#g2148290d2cf9c1961ec157a085badd5a">bind()</a> or returned by <a class="el" href="group__bind.html#g8a001b0bb588d2ac1af712781b89dc8a">bind_return()</a> by const reference, specialized for const reference_wrapper&lt;&gt; types.  <a href="classsigc_1_1bound__argument_3_01const__reference__wrapper_3_01T__wrapped_01_4_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that combines two functors.  <a href="structsigc_1_1compose1__functor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that combines three functors.  <a href="structsigc_1_1compose2__functor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__base.html">adaptor_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hint to the compiler.  <a href="structsigc_1_1adaptor__base.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type.html">deduce_result_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor.  <a href="structsigc_1_1deduce__result__type.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01void_00_01void_00_01void_00_01void_00_01vdb2f9f83b3eba2baeb19678a790211a3.html">deduce_result_type&lt;T_functor, void, void, void, void, void, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor.  <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01void_00_01void_00_01void_00_01void_00_01vdb2f9f83b3eba2baeb19678a790211a3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01void_00_01void_00_01void_00_f4c559613b292c7b689426d5c155df15.html">deduce_result_type&lt;T_functor, T_arg1, void, void, void, void, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor.  <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01void_00_01void_00_01void_00_f4c559613b292c7b689426d5c155df15.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01void_00_01void_724dd7c759e838f48e6fa6545d8e015d.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, void, void, void, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor.  <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01void_00_01void_724dd7c759e838f48e6fa6545d8e015d.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01vo258d7260cbbb4e192063ff2984a0677a.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, T_arg3, void, void, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor.  <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01vo258d7260cbbb4e192063ff2984a0677a.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_9b37fe7be1f2633448bc6b77ab8f97ff.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, T_arg3, T_arg4, void, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor.  <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_9b37fe7be1f2633448bc6b77ab8f97ff.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_d8ef7847af7e7170bed8f3a632586811.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, void, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor.  <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_d8ef7847af7e7170bed8f3a632586811.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_4788a98c68901ad51b4daf97aed5e129.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, void, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor.  <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_4788a98c68901ad51b4daf97aed5e129.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_5c3a161eb5dba3c597d379b0bd504e5f.html">deduce_result_type&lt;T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduce the return type of a functor.  <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_5c3a161eb5dba3c597d379b0bd504e5f.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1exception__catch__functor.html">exception_catch_functor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1exception__catch__functor_3_01T__functor_00_01T__catcher_00_01void_01_4.html">exception_catch_functor&lt;T_functor, T_catcher, void&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3-1_00_01T__functor_01_4.html">hide_functor&lt;-1, T_functor &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor.  <a href="structsigc_1_1hide__functor_3-1_00_01T__functor_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_010_00_01T__functor_01_4.html">hide_functor&lt;0, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor.  <a href="structsigc_1_1hide__functor_3_010_00_01T__functor_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_011_00_01T__functor_01_4.html">hide_functor&lt;1, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor.  <a href="structsigc_1_1hide__functor_3_011_00_01T__functor_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_012_00_01T__functor_01_4.html">hide_functor&lt;2, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor.  <a href="structsigc_1_1hide__functor_3_012_00_01T__functor_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_013_00_01T__functor_01_4.html">hide_functor&lt;3, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor.  <a href="structsigc_1_1hide__functor_3_013_00_01T__functor_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_014_00_01T__functor_01_4.html">hide_functor&lt;4, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor.  <a href="structsigc_1_1hide__functor_3_014_00_01T__functor_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_015_00_01T__functor_01_4.html">hide_functor&lt;5, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor.  <a href="structsigc_1_1hide__functor_3_015_00_01T__functor_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_016_00_01T__functor_01_4.html">hide_functor&lt;6, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor.  <a href="structsigc_1_1hide__functor_3_016_00_01T__functor_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__base.html">lambda_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hint to the compiler.  <a href="structsigc_1_1lambda__base.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda.html">lambda</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lambda type.  <a href="structsigc_1_1lambda.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduces the type of the object stored in an object of the passed lambda type.  <a href="structsigc_1_1unwrap__lambda__type.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__lambda__type_3_01lambda_3_01T__type_01_4_01_4.html">unwrap_lambda_type&lt;lambda&lt;T_type&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__group1.html">lambda_group1</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__group2.html">lambda_group2</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__group3.html">lambda_group3</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait.html">dereference_trait</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduces the base type of a reference or a pointer.  <a href="structsigc_1_1dereference__trait.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01T__type_01_5_01_4.html">dereference_trait&lt;T_type*&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01const_01T__type_01_5_01_4.html">dereference_trait&lt;const T_type*&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01T__type_01_5_6_01_4.html">dereference_trait&lt;T_type*&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01const_01T__type_01_5_6_01_4.html">dereference_trait&lt;const T_type*&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01T__type_01_5const_01_6_01_4.html">dereference_trait&lt;T_type* const&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait_3_01const_01T__type_01_5const_01_6_01_4.html">dereference_trait&lt;const T_type* const&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bitwise.html">bitwise</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1logical.html">logical</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1relational.html">relational</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1other.html">other</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unary__bitwise.html">unary_bitwise</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unary__logical.html">unary_logical</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unary__other.html">unary_other</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1cast__.html">cast_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1plus.html">plus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1minus.html">minus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1multiplies.html">multiplies</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1divides.html">divides</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1modulus.html">modulus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1leftshift.html">leftshift</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1rightshift.html">rightshift</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1and__.html">and_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1or__.html">or_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1xor__.html">xor_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1less.html">less</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1greater.html">greater</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1less__equal.html">less_equal</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1equal__to.html">equal_to</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1subscript.html">subscript</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1assign.html">assign</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1pre__increment.html">pre_increment</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1pre__decrement.html">pre_decrement</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1negate.html">negate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1not__.html">not_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1address.html">address</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference.html">dereference</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1reinterpret__.html">reinterpret_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1static__.html">static_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dynamic__.html">dynamic_</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type.html">lambda_action_deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01logical_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">lambda_action_deduce_result_type&lt;logical&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01relational_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">lambda_action_deduce_result_type&lt;relational&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01arithmetic__assign_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">lambda_action_deduce_result_type&lt;arithmetic_assign&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01bitwise__assign_3_01T__action_01_4_00_01T__test1_00_01T__test2_01_4.html">lambda_action_deduce_result_type&lt;bitwise_assign&lt;T_action&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__deduce__result__type_3_01other_3_01subscript_01_4_00_01T__test1_00_01T__test2_01_4.html">lambda_action_deduce_result_type&lt;other&lt;subscript&gt;, T_test1, T_test2&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type.html">lambda_action_unary_deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__convert__deduce__result__type.html">lambda_action_convert_deduce_result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type_3_01unary__logical_3_01T__action_01_4_00_01T__test_01_4.html">lambda_action_unary_deduce_result_type&lt;unary_logical&lt;T_action&gt;, T_test&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type_3_01unary__other_3_01address_01_4_00_01T__test_01_4.html">lambda_action_unary_deduce_result_type&lt;unary_other&lt;address&gt;, T_test&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary__deduce__result__type_3_01unary__other_3_01dereference_01_4_00_01T__test_01_4.html">lambda_action_unary_deduce_result_type&lt;unary_other&lt;dereference&gt;, T_test&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action.html">lambda_action</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary.html">lambda_action_unary</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__convert.html">lambda_action_convert</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01plus_01_4_01_4.html">lambda_action&lt;arithmetic&lt;plus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01minus_01_4_01_4.html">lambda_action&lt;arithmetic&lt;minus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01multiplies_01_4_01_4.html">lambda_action&lt;arithmetic&lt;multiplies&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01divides_01_4_01_4.html">lambda_action&lt;arithmetic&lt;divides&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic_3_01modulus_01_4_01_4.html">lambda_action&lt;arithmetic&lt;modulus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01leftshift_01_4_01_4.html">lambda_action&lt;bitwise&lt;leftshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01rightshift_01_4_01_4.html">lambda_action&lt;bitwise&lt;rightshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01and___01_4_01_4.html">lambda_action&lt;bitwise&lt;and_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01or___01_4_01_4.html">lambda_action&lt;bitwise&lt;or_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise_3_01xor___01_4_01_4.html">lambda_action&lt;bitwise&lt;xor_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01logical_3_01and___01_4_01_4.html">lambda_action&lt;logical&lt;and_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01logical_3_01or___01_4_01_4.html">lambda_action&lt;logical&lt;or_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01less_01_4_01_4.html">lambda_action&lt;relational&lt;less&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01greater_01_4_01_4.html">lambda_action&lt;relational&lt;greater&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01less__equal_01_4_01_4.html">lambda_action&lt;relational&lt;less_equal&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01greater__equal_01_4_01_4.html">lambda_action&lt;relational&lt;greater_equal&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01equal__to_01_4_01_4.html">lambda_action&lt;relational&lt;equal_to&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01relational_3_01not__equal__to_01_4_01_4.html">lambda_action&lt;relational&lt;not_equal_to&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01plus_01_4_01_4.html">lambda_action&lt;arithmetic_assign&lt;plus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01minus_01_4_01_4.html">lambda_action&lt;arithmetic_assign&lt;minus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01multiplies_01_4_01_4.html">lambda_action&lt;arithmetic_assign&lt;multiplies&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01divides_01_4_01_4.html">lambda_action&lt;arithmetic_assign&lt;divides&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01arithmetic__assign_3_01modulus_01_4_01_4.html">lambda_action&lt;arithmetic_assign&lt;modulus&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01leftshift_01_4_01_4.html">lambda_action&lt;bitwise_assign&lt;leftshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01rightshift_01_4_01_4.html">lambda_action&lt;bitwise_assign&lt;rightshift&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01and___01_4_01_4.html">lambda_action&lt;bitwise_assign&lt;and_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01or___01_4_01_4.html">lambda_action&lt;bitwise_assign&lt;or_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01bitwise__assign_3_01xor___01_4_01_4.html">lambda_action&lt;bitwise_assign&lt;xor_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01other_3_01subscript_01_4_01_4.html">lambda_action&lt;other&lt;subscript&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action_3_01other_3_01assign_01_4_01_4.html">lambda_action&lt;other&lt;assign&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__arithmetic_3_01pre__increment_01_4_01_4.html">lambda_action_unary&lt;unary_arithmetic&lt;pre_increment&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__arithmetic_3_01pre__decrement_01_4_01_4.html">lambda_action_unary&lt;unary_arithmetic&lt;pre_decrement&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__arithmetic_3_01negate_01_4_01_4.html">lambda_action_unary&lt;unary_arithmetic&lt;negate&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__bitwise_3_01not___01_4_01_4.html">lambda_action_unary&lt;unary_bitwise&lt;not_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__logical_3_01not___01_4_01_4.html">lambda_action_unary&lt;unary_logical&lt;not_&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__other_3_01address_01_4_01_4.html">lambda_action_unary&lt;unary_other&lt;address&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__unary_3_01unary__other_3_01dereference_01_4_01_4.html">lambda_action_unary&lt;unary_other&lt;dereference&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__convert_3_01cast___3_01reinterpret___01_4_00_01T__type_01_4.html">lambda_action_convert&lt;cast_&lt;reinterpret_&gt;, T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__convert_3_01cast___3_01static___01_4_00_01T__type_01_4.html">lambda_action_convert&lt;cast_&lt;static_&gt;, T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__action__convert_3_01cast___3_01dynamic___01_4_00_01T__type_01_4.html">lambda_action_convert&lt;cast_&lt;dynamic_&gt;, T_type&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that performs C-style casts on the parameters passed on to the functor.  <a href="structsigc_1_1retype__functor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that perform a C-style cast on the return value of a functor.  <a href="structsigc_1_1retype__return__functor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__return__functor_3_01void_00_01T__functor_01_4.html">retype_return_functor&lt;void, T_functor&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adaptor that perform a C-style cast on the return value of a functor.  <a href="structsigc_1_1retype__return__functor_3_01void_00_01T__functor_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1connection.html">connection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convinience class for safe disconnection.  <a href="structsigc_1_1connection.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__base.html">functor_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hint to the compiler.  <a href="structsigc_1_1functor__base.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait.html">functor_trait</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__functor_00_01true_01_4.html">functor_trait&lt;T_functor, true&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)()_00_01false_01_4.html">functor_trait&lt;T_return(*)(), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2_00_01T__arg3)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2, T_arg3), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5)_00_01false_01_4.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00f8faa1edfe8c00c4734ad6529136c5af.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_004f9c9d87122253a1819d1e9beb5459d7.html">functor_trait&lt;T_return(*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a> wraps methods with 0 argument(s).  <a href="classsigc_1_1mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a> wraps methods with 1 argument(s).  <a href="classsigc_1_1mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a> wraps methods with 2 argument(s).  <a href="classsigc_1_1mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a> wraps methods with 3 argument(s).  <a href="classsigc_1_1mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a> wraps methods with 4 argument(s).  <a href="classsigc_1_1mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a> wraps methods with 5 argument(s).  <a href="classsigc_1_1mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a> wraps methods with 6 argument(s).  <a href="classsigc_1_1mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a> wraps methods with 7 argument(s).  <a href="classsigc_1_1mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a> wraps const methods with 0 argument(s).  <a href="classsigc_1_1const__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a> wraps const methods with 1 argument(s).  <a href="classsigc_1_1const__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a> wraps const methods with 2 argument(s).  <a href="classsigc_1_1const__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a> wraps const methods with 3 argument(s).  <a href="classsigc_1_1const__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a> wraps const methods with 4 argument(s).  <a href="classsigc_1_1const__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a> wraps const methods with 5 argument(s).  <a href="classsigc_1_1const__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a> wraps const methods with 6 argument(s).  <a href="classsigc_1_1const__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a> wraps const methods with 7 argument(s).  <a href="classsigc_1_1const__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a> wraps volatile methods with 0 argument(s).  <a href="classsigc_1_1volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a> wraps volatile methods with 1 argument(s).  <a href="classsigc_1_1volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a> wraps volatile methods with 2 argument(s).  <a href="classsigc_1_1volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a> wraps volatile methods with 3 argument(s).  <a href="classsigc_1_1volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a> wraps volatile methods with 4 argument(s).  <a href="classsigc_1_1volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a> wraps volatile methods with 5 argument(s).  <a href="classsigc_1_1volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a> wraps volatile methods with 6 argument(s).  <a href="classsigc_1_1volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a> wraps volatile methods with 7 argument(s).  <a href="classsigc_1_1volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a> wraps const volatile methods with 0 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a> wraps const volatile methods with 1 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a> wraps const volatile methods with 2 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a> wraps const volatile methods with 3 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a> wraps const volatile methods with 4 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a> wraps const volatile methods with 5 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a> wraps const volatile methods with 6 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a> wraps const volatile methods with 7 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a> encapsulates a method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a> encapsulates a method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a> encapsulates a method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a> encapsulates a method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a> encapsulates a method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a> encapsulates a method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a> encapsulates a method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a> encapsulates a method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a> encapsulates a const method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a> encapsulates a const method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a> encapsulates a const method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a> encapsulates a const method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a> encapsulates a const method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a> encapsulates a const method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a> encapsulates a const method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a> encapsulates a const method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a> encapsulates a volatile method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a> encapsulates a volatile method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a> encapsulates a volatile method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a> encapsulates a volatile method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a> encapsulates a volatile method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a> encapsulates a volatile method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a> encapsulates a volatile method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a> encapsulates a volatile method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a> encapsulates a const volatile method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a> encapsulates a const volatile method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a> encapsulates a const volatile method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a> encapsulates a const volatile method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a> encapsulates a const volatile method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a> encapsulates a const volatile method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a> encapsulates a const volatile method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a> encapsulates a const volatile method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a> wraps existing non-member functions with 0 argument(s).  <a href="classsigc_1_1pointer__functor0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a> wraps existing non-member functions with 1 argument(s).  <a href="classsigc_1_1pointer__functor1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a> wraps existing non-member functions with 2 argument(s).  <a href="classsigc_1_1pointer__functor2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a> wraps existing non-member functions with 3 argument(s).  <a href="classsigc_1_1pointer__functor3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a> wraps existing non-member functions with 4 argument(s).  <a href="classsigc_1_1pointer__functor4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a> wraps existing non-member functions with 5 argument(s).  <a href="classsigc_1_1pointer__functor5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a> wraps existing non-member functions with 6 argument(s).  <a href="classsigc_1_1pointer__functor6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a> wraps existing non-member functions with 7 argument(s).  <a href="classsigc_1_1pointer__functor7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot0.html">slot0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot1.html">slot1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot2.html">slot2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot3.html">slot3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot4.html">slot4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot5.html">slot5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot6.html">slot6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot7.html">slot7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot.html">slot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot.html">sigc::slot</a># templates.  <a href="classsigc_1_1slot.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt;T_return, nil, nil, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot0.html">sigc::slot0</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt;T_return, T_arg1, nil, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot1.html">sigc::slot1</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt;T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot2.html">sigc::slot2</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt;T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot3.html">sigc::slot3</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot4.html">sigc::slot4</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html">slot&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot5.html">sigc::slot5</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html">slot&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot6.html">sigc::slot6</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot__base.html">slot_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base type for slots.  <a href="classsigc_1_1slot__base.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1limit__reference.html">limit_reference</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a>, then <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> reference instead of the derived reference.  <a href="classsigc_1_1limit__reference.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1limit__reference_3_01T__type_00_01true_01_4.html">limit_reference&lt;T_type, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1limit__reference.html">limit_reference</a> object for a class that derives from trackable.  <a href="classsigc_1_1limit__reference_3_01T__type_00_01true_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__limit__reference.html">const_limit_reference</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a>, then <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> reference instead of the derived reference.  <a href="classsigc_1_1const__limit__reference.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__limit__reference_3_01T__type_00_01true_01_4.html">const_limit_reference&lt;T_type, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__limit__reference.html">const_limit_reference</a> object for a class that derives from trackable.  <a href="classsigc_1_1const__limit__reference_3_01T__type_00_01true_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__limit__reference.html">volatile_limit_reference</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a>, then <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> reference instead of the derived reference.  <a href="classsigc_1_1volatile__limit__reference.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__limit__reference_3_01T__type_00_01true_01_4.html">volatile_limit_reference&lt;T_type, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__limit__reference.html">volatile_limit_reference</a> object for a class that derives from trackable.  <a href="classsigc_1_1volatile__limit__reference_3_01T__type_00_01true_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__limit__reference.html">const_volatile_limit_reference</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a>, then <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> reference instead of the derived reference.  <a href="classsigc_1_1const__volatile__limit__reference.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__limit__reference_3_01T__type_00_01true_01_4.html">const_volatile_limit_reference&lt;T_type, true&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__limit__reference.html">const_volatile_limit_reference</a> object for a class that derives from trackable.  <a href="classsigc_1_1const__volatile__limit__reference_3_01T__type_00_01true_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference wrapper.  <a href="structsigc_1_1reference__wrapper.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const reference wrapper.  <a href="structsigc_1_1const__reference__wrapper.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__reference_3_01reference__wrapper_3_01T__type_01_4_01_4.html">unwrap_reference&lt;reference_wrapper&lt;T_type&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__reference_3_01const__reference__wrapper_3_01T__type_01_4_01_4.html">unwrap_reference&lt;const_reference_wrapper&lt;T_type&gt;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__iterator.html">slot_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-style iterator for <a class="el" href="structsigc_1_1slot__list.html">slot_list</a>.  <a href="structsigc_1_1slot__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__const__iterator.html">slot_const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-style const iterator for <a class="el" href="structsigc_1_1slot__list.html">slot_list</a>.  <a href="structsigc_1_1slot__const__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__list.html">slot_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-style list interface for <a class="el" href="classsigc_1_1signal.html">sigc::signal</a>#.  <a href="structsigc_1_1slot__list.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal0.html">signal0</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal0.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal1.html">signal1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal1.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal2.html">signal2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal2.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html">signal3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal3.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal4.html">signal4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal5.html">signal5</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal5.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal6.html">signal6</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal6.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal7.html">signal7</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal7.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal.html">signal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal.html">sigc::signal</a># templates.  <a href="classsigc_1_1signal.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt;T_return, nil, nil, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal0.html">sigc::signal0</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt;T_return, T_arg1, nil, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal1.html">sigc::signal1</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt;T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal2.html">sigc::signal2</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal4.html">sigc::signal4</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal5.html">sigc::signal5</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html">signal&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil&gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal6.html">sigc::signal6</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1signal__base.html">signal_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for the <a class="el" href="classsigc_1_1signal.html">sigc::signal</a># templates.  <a href="structsigc_1_1signal__base.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1trackable.html">trackable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for objects with auto-disconnection.  <a href="structsigc_1_1trackable.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1type__trait.html">type_trait</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1type__trait_3_01T__type[N]_4.html">type_trait&lt; T_type[N]&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1type__trait_3_01T__type_01_6_01_4.html">type_trait&lt;T_type&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1type__trait_3_01const_01T__type_01_6_01_4.html">type_trait&lt;const T_type&amp;&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1type__trait_3_01void_01_4.html">type_trait&lt;void&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1is__base__and__derived.html">is_base_and_derived</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compile-time determination of base-class relationship in C++ (adapted to match the syntax of boost's type_traits library).  <a href="structsigc_1_1is__base__and__derived.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1is__base__and__derived_3_01T__base_00_01T__base_01_4.html">is_base_and_derived&lt;T_base, T_base&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)()_00_01false_01_4.html">functor_trait&lt;T_return(T_obj::*)(), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)()_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj::*)() const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1)_00_01false_01_4.html">functor_trait&lt;T_return(T_obj::*)(T_arg1), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1)_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj::*)(T_arg1) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2)_00_01false_01_4.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2)_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3)_00_01false_01_4.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2, T_arg3), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3)_01const_00_01false_01_4.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2, T_arg3) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4)_00_01false_01_4.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_015071c56f0e0d7a7d55483dbb2eb6cb42.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_012f3cd1a918b83864a027f5dde7e6e822.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_012c47e7de3cf754c7c14b6e1819d0803c.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_0111aed1ad908b410000f77ed067bc242e.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_017b31a2c9fdd955c87a204ef3048b4df3.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const, false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01c07573bd5b0df80fd2a3218f3a082998.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7), false&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait_3_01T__return(T__obj_1_1_5)(T__arg1_00_01T__arg2_00_01T__arg3_00_01e1b17a8788250985f9518122bdd7a5db.html">functor_trait&lt;T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const, false&gt;</a></td></tr>

<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesigc_1_1internal.html">internal</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1adaptor__functor.html">adaptor_functor</a>&lt;T_functor&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, int T_loc, class T_functor, class T_bound&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ged4a6aaa9d804f82fd558d553b67c3a8">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;T_loc, T_functor, T_bound&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__bind.html#ged4a6aaa9d804f82fd558d553b67c3a8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_type1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#g97d5feac063beaf49157990f98aad6fe">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__bind.html#g97d5feac063beaf49157990f98aad6fe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_type1, class T_type2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gca2e99785599f7631337d5fbbecbc610">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__bind.html#gca2e99785599f7631337d5fbbecbc610"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gb9bc9f3ffe4a706128948eb00751eadc">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__bind.html#gb9bc9f3ffe4a706128948eb00751eadc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga60aa29a584517ad422473281ce2864b">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__bind.html#ga60aa29a584517ad422473281ce2864b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#g5237d6d834423536367bf130760e88b3">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__bind.html#g5237d6d834423536367bf130760e88b3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#g5017f20f5c99a9a1007476a397e6b0af">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__bind.html#g5017f20f5c99a9a1007476a397e6b0af"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gb7f865e06297273a2b5d80b7d7865bdb">visit_each</a> (const T_action&amp; _A_action, const bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__bind.html#gb7f865e06297273a2b5d80b7d7865bdb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;int I_location, class T_bound1, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bind_functor&lt; I_location,<br>
 T_functor, T_bound1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#g2148290d2cf9c1961ec157a085badd5a">bind</a> (const T_functor&amp; _A_func, T_bound1 _A_b1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor.  <a href="group__bind.html#g2148290d2cf9c1961ec157a085badd5a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type1, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bind_functor&lt;-1, T_functor,<br>
 T_type1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#g5858818e62c9df7ded906d9461d012cd">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 1 argument(s) of the passed functor.  <a href="group__bind.html#g5858818e62c9df7ded906d9461d012cd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type1, class T_type2, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bind_functor&lt;-1, T_functor,<br>
 T_type1, T_type2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#g68057ec737e31fa433a0a5f726f27cd1">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 2 argument(s) of the passed functor.  <a href="group__bind.html#g68057ec737e31fa433a0a5f726f27cd1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type1, class T_type2, class T_type3, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bind_functor&lt;-1, T_functor,<br>
 T_type1, T_type2, T_type3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#g006c34f47e2a19358be290d438c0de19">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 3 argument(s) of the passed functor.  <a href="group__bind.html#g006c34f47e2a19358be290d438c0de19"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type1, class T_type2, class T_type3, class T_type4, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bind_functor&lt;-1, T_functor,<br>
 T_type1, T_type2, T_type3,<br>
 T_type4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gafb060da662d2ab98bf377c16a5df8f4">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 4 argument(s) of the passed functor.  <a href="group__bind.html#gafb060da662d2ab98bf377c16a5df8f4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bind_functor&lt;-1, T_functor,<br>
 T_type1, T_type2, T_type3,<br>
 T_type4, T_type5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ge20edab579c98fecb975a5cc698d8ab2">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 5 argument(s) of the passed functor.  <a href="group__bind.html#ge20edab579c98fecb975a5cc698d8ab2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bind_functor&lt;-1, T_functor,<br>
 T_type1, T_type2, T_type3,<br>
 T_type4, T_type5, T_type6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#g7f4b6bd72965b7840fa5b518e0d069c1">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 6 argument(s) of the passed functor.  <a href="group__bind.html#g7f4b6bd72965b7840fa5b518e0d069c1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bind_functor&lt;-1, T_functor,<br>
 T_type1, T_type2, T_type3,<br>
 T_type4, T_type5, T_type6,<br>
 T_type7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#g356da93520385d48f66125257d2b8f2b">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6, T_type7 _A_b7)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 7 argument(s) of the passed functor.  <a href="group__bind.html#g356da93520385d48f66125257d2b8f2b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#g27e8bea76ba380b8223b059369b2c485">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a>&lt;T_return, T_functor&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__bind.html#g27e8bea76ba380b8223b059369b2c485"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a>&lt; T_return,<br>
 T_functor &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#g8a001b0bb588d2ac1af712781b89dc8a">bind_return</a> (const T_functor&amp; _A_functor, T_return _A_ret_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__return__functor.html">sigc::bind_return_functor</a> which fixes the return value of the passed functor to the passed argument.  <a href="group__bind.html#g8a001b0bb588d2ac1af712781b89dc8a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#78af6ff8fb24c17f5e72fd36d0be7975">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a>&lt;T_type&gt;&amp; _A_argument)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a> class.  <a href="#78af6ff8fb24c17f5e72fd36d0be7975"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_setter, class T_getter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#g3e7453863caa786e5e6a0401a8450958">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a>&lt;T_setter, T_getter&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__compose.html#g3e7453863caa786e5e6a0401a8450958"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_setter, class T_getter1, class T_getter2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#g234770a49ae510afbf6530047005294e">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a>&lt;T_setter, T_getter1, T_getter2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__compose.html#g234770a49ae510afbf6530047005294e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_setter, class T_getter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a>&lt; T_setter,<br>
 T_getter &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#g57692495ec80dd855d4653adde4c8f49">compose</a> (const T_setter&amp; _A_setter, const T_getter&amp; _A_getter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1compose1__functor.html">sigc::compose1_functor</a> which combines two functors.  <a href="group__compose.html#g57692495ec80dd855d4653adde4c8f49"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_setter, class T_getter1, class T_getter2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a>&lt; T_setter,<br>
 T_getter1, T_getter2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#g5ccef00a13aa5672806c46d4abe4ce55">compose</a> (const T_setter&amp; _A_setter, const T_getter1&amp; _A_getter1, const T_getter2&amp; _A_getter2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1compose2__functor.html">sigc::compose2_functor</a> which combines three functors.  <a href="group__compose.html#g5ccef00a13aa5672806c46d4abe4ce55"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_catcher, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a223e54f7b85d4234b330a1c8502b6ba">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1exception__catch__functor.html">exception_catch_functor</a>&lt;T_functor, T_catcher, T_return&gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_functor, class T_catcher&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1exception__catch__functor.html">exception_catch_functor</a>&lt; T_functor,<br>
 T_catcher &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#9aee9af00f94197bed616f6a5059c491">exception_catch</a> (const T_functor&amp; _A_func, const T_catcher&amp; _A_catcher)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, int I_location, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#ga07f0ffec52a12cd7dcf1601938b247c">visit_each</a> (const T_action&amp; _A_action, const hide_functor&lt;I_location, T_functor&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__hide.html#ga07f0ffec52a12cd7dcf1601938b247c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;int I_location, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">hide_functor&lt; I_location,<br>
 T_functor &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#g6e9653e79dbd111f458a2ccd690dadc6">hide</a> (const T_functor&amp; _A_func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type sigc::hide_functor which adds a dummy parameter to the passed functor.  <a href="group__hide.html#g6e9653e79dbd111f458a2ccd690dadc6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, bool I_islambda&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#c14e861d541fd6172fd66bd96b79d3c1">visit_each</a> (const T_action&amp; _A_action, const internal::lambda_core&lt;T_functor, I_islambda&gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#6df6801c9173642c618ac337112bb2b7">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_type&gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_type&amp;&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a354a134fa27b2dc8295af1c871b5885">var</a> (T_type&amp; v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a reference into a lambda object.  <a href="#a354a134fa27b2dc8295af1c871b5885"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;const T_type&amp;&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#d0f037b8944e6c5828ccbffa28726525">var</a> (const T_type&amp; v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a constant reference into a lambda object.  <a href="#d0f037b8944e6c5828ccbffa28726525"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T_type&amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#72c9f563f8d97738fa8d3d494e0ff0f5">unwrap_lambda_value</a> (T_type&amp; a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the object stored inside a lambda object.  <a href="#72c9f563f8d97738fa8d3d494e0ff0f5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const T_type&amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#6d9b97698fd134e2ec1e103fbe893b07">unwrap_lambda_value</a> (const T_type&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const T_type&amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#55f65aefeb2254213ed4149610c58e16">unwrap_lambda_value</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_type&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_type1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#f281160792e31db1dac80bc28a932ce9">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__group1.html">lambda_group1</a>&lt;T_functor, T_type1&gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_type1, class T_type2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#3c1afe7cb631539be654133b0c1b35fc">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__group2.html">lambda_group2</a>&lt;T_functor, T_type1, T_type2&gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#93983affe370fea0a52fe7f8f47ff7ba">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__group3.html">lambda_group3</a>&lt;T_functor, T_type1, T_type2, T_type3&gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_functor, class T_type1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__group1.html">lambda_group1</a>&lt; T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#d36281e6ca158599b36980a801f41aac">group</a> (const T_functor&amp; _A_func, T_type1 _A_1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_functor, class T_type1, class T_type2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__group2.html">lambda_group2</a>&lt; T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#948eb594b3254c2efbe88d1dbb4d35dc">group</a> (const T_functor&amp; _A_func, T_type1 _A_1, T_type2 _A_2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_functor, class T_type1, class T_type2, class T_type3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__group3.html">lambda_group3</a>&lt; T_functor,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type1 &gt;::type, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 <br>
&gt;::type, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_type3 &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#373b1216c685961b9d073e300cbda78f">group</a> (const T_functor&amp; _A_func, T_type1 _A_1, T_type2 _A_2, T_type3 _A_3)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_lambda_action, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#eff5a0299fefc2899b6a920ec35539b1">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;T_lambda_action, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_lambda_action, class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#63a15030d38a903406a7f0e3b4ef220a">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;T_lambda_action, T_arg&gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_lambda_action, class T_type, class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#3413af839d2a7c15cbcd24e5d3098542">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;T_lambda_action, T_type, T_arg&gt;&amp; _A_target)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#29d226d0e89c123a6a99df7cf7049e98">operator+</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#cc0c03760fce65203d5f67f23a05aee7">operator+</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#74d41ed6e82b12e9d2079776d1381a1b">operator+</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#26c54de4f570705ef709f745a1ded9c7">operator-</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ebf7d41a285af52c58329c66183aca15">operator-</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#000e30854e2ad97c82db1c8e55ae9c58">operator-</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#96302d55d9f9487b85bd723983bf7dc8">operator*</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#b8250f41a97fbcaf00f38e3cdac71880">operator*</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#db9970b1407a0d915eefd423acfc2af6">operator*</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2cd49ce61ca95eef20291ceaaa14f7f3">operator/</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#04d7fd3f8ecfe2ace16a5f03c318a56d">operator/</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#778da0346854b55c0605811e427f7ece">operator/</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#448f704e10cf7099d202544144257829">operator%</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#0df1bd3cac2a2bfbb43d250aec11b171">operator%</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#8900336dc8fbdcc1719095a98728aa07">operator%</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2be0aea0eb8880432737d42fa166a226">operator&lt;&lt;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#43931fdef62a0517ba0924de2f82d0a9">operator&lt;&lt;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#15266193ad2aad0a0b5c77b9d54f778e">operator&lt;&lt;</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#f82dddd5da2b904553cac0cbe28fbdef">operator&gt;&gt;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#5d32e408b09d4b18017401a618deca22">operator&gt;&gt;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#961c52af18d38be10448d6305875ec42">operator&gt;&gt;</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#461df6e22a0f398518cba4a6d188afc9">operator&amp;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#c98c7424a1a331909cfe0e2a0761c18f">operator&amp;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#cf462bfb7b85b19e4e4308c9a27ffcc2">operator&amp;</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#7d613863e01f8cf39a3f7a67be586b37">operator|</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#79c58fce0596a170e3eb32aa589aa573">operator|</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2298b1d7394469e603ef17122d29e2c5">operator|</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#9bd6e35894b866758aa37ec441e46c1b">operator^</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#f5b039f488caaf8422ce7e04f8d22fd2">operator^</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#455402cbd5b9af2923150b24f1b586ed">operator^</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#f68affa8bbefac3b556d333240a97f3e">operator&amp;&amp;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#bca5b3586ae165f374e0ecda6e742368">operator&amp;&amp;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#9a43e8f2ed62653f3cdd1c7fc822eac1">operator&amp;&amp;</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#5c4eea4d6cfb47d019091f7b64177dcc">operator||</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#be7b14c8d37e24cc62259aba382f5b3e">operator||</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#b185848c59fea219a747cb1009f1c881">operator||</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less.html">less</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#64587ad0e3a569be542d546b9b1d9829">operator&lt;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less.html">less</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a0f064417347c15e6c2eee46645f4b58">operator&lt;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less.html">less</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#e84ae7410cde285a4062beec3f2581dd">operator&lt;</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater.html">greater</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#82df52344c1995f4b7f66efa2c6dd1e1">operator&gt;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater.html">greater</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#aed6caf81d925870fbc306ecaf562a9a">operator&gt;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater.html">greater</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#56f75748c8b6018401b8f82a93f29a58">operator&gt;</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less__equal.html">less_equal</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#276ae53620c9234c7964816aa94ba476">operator&lt;=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less__equal.html">less_equal</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ffb5949de125154ba78a9fab53e5c88f">operator&lt;=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1less__equal.html">less_equal</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#4a9e25129fc0832aa465ce7ec679a1be">operator&lt;=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a> &gt;, T_arg1,<br>
 T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#e1c71b2dfbafd2701d1ee7be0a5c603b">operator&gt;=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a> &gt;, T_arg1,<br>
 typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#109def8701355bae896321317c9fbda3">operator&gt;=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a> &gt;, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg1 <br>
&gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#8783dd0b543f6b51467ec1256a694174">operator&gt;=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1equal__to.html">equal_to</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#3d4a437822ac13a0b06f8d629f162441">operator==</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1equal__to.html">equal_to</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#6a642d0f9179d581a95ac21ad10003b5">operator==</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1equal__to.html">equal_to</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#934ffbd686558b72a1ee12e4d9207a93">operator==</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2e406f67fa7336e1e6af7f2b6de89563">operator!=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#35550c6b98eab98d75f088abb1c06f6d">operator!=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<br>
 <a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a> &gt;, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg1 <br>
&gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#0fc828769dcf706797f1b39f88b770f9">operator!=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#e4450395ac4750ab095b170da8dfc0a0">operator+=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#334380d2c5ffd5febefb5aa0bfc6d162">operator+=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1plus.html">plus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#4f0fa4bcad9e6a2f2d084ae4d0253acc">operator+=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#053d463f15272d949eddd17c1eb6057c">operator-=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#098d8644120cfbecfce6c2fdf3dcf4fe">operator-=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1minus.html">minus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#3f5f33195e31cf10b663d60bee6624be">operator-=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#f0221188780339a72bddffa5e64a24a6">operator*=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#4310d9b5aeb6048b08cce89273d11d9c">operator*=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1multiplies.html">multiplies</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#db177314c99341fd5b57f65989a31e10">operator*=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#8749ada1d603fb667f3170e056c3d3fe">operator/=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#190f94964b496b4389ff0695459c97f2">operator/=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1divides.html">divides</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#91c8284788f629046b289b1b8bb92fd2">operator/=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a22758b40768e4e1d5292711819e73f6">operator%=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#69bde4f0ffcf252e7b41e28c541943ba">operator%=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1modulus.html">modulus</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#c5379cb4329503d13767b738a076b157">operator%=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#717ad3389bb00a107750f9134d6170ef">operator&lt;&lt;=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#7d37efde4fa6742ef6090076ffde6d26">operator&lt;&lt;=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1leftshift.html">leftshift</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a3c8ebf217044832c473285315d0c978">operator&lt;&lt;=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#002b4794715b5156dd45588364e52263">operator&gt;&gt;=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#898e016d767b6caa5dbf55b2df889524">operator&gt;&gt;=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1rightshift.html">rightshift</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#77622d65d029ad3e13ed40e5c6506195">operator&gt;&gt;=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a25d6e499bf8c44cfd04d2900ca4a156">operator&amp;=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#cac27c3e543578eb522f66c1612435bb">operator&amp;=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1and__.html">and_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#56cab772bbbecd16ed69b0b3897d7622">operator&amp;=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#188bc271d74500df8b312869b7db9100">operator|=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg2 &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#38281683e4f30ae38ebd9a77acadd68c">operator|=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1or__.html">or_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#5a32da57863bbe61bca7ef039e1e6c3a">operator|=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, T_arg1, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2108c7da0f2be4495e270b156f30cedd">operator^=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, T_arg1, typename <br>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_arg2 <br>
&gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#9fa6e2ff33616025e04285d6ad985b87">operator^=</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg1&gt;&amp; a1, const T_arg2&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<br>
 <a class="el" href="structsigc_1_1xor__.html">xor_</a> &gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;<br>
 T_arg1 &gt;::type, T_arg2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a1f413cd83d012ce882fcb2654bd9ca2">operator^=</a> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg2&gt;&amp; a2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1pre__increment.html">pre_increment</a>&gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#e9659bd5e4dafbdbef94794ab280fd44">operator++</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1pre__decrement.html">pre_decrement</a>&gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#979840b7fcd28955b01524d2d352a731">operator--</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1negate.html">negate</a>&gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a1e0215bf7c7cec50a46b4fbc5e09f88">operator-</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__bitwise.html">unary_bitwise</a>&lt;<a class="el" href="structsigc_1_1not__.html">not_</a> &gt;, T_arg &gt;&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#db7ab85e9d37fd0d23e68c39d4c9f7ae">operator~</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__logical.html">unary_logical</a>&lt;<a class="el" href="structsigc_1_1not__.html">not_</a> &gt;, T_arg &gt;&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#1f087b34043a9ddd59fd58da582e4349">operator!</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__other.html">unary_other</a>&lt;<a class="el" href="structsigc_1_1address.html">address</a> &gt;, T_arg &gt;&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#8d9d07ddf7ce8aec640d92b45db91309">operator&amp;</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<br>
 <a class="el" href="structsigc_1_1unary__other.html">unary_other</a>&lt;<a class="el" href="structsigc_1_1dereference.html">dereference</a>&gt;,<br>
 T_arg &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#977f37aadcfd2fc5045800bdfd81cde1">operator*</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_arg&gt;&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type, class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<br>
 <a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1reinterpret__.html">reinterpret_</a>&gt;, T_type,<br>
 typename <a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a>&lt;<br>
 T_arg &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#0ba07befc70db9c92da9a0ba298b7c4e">reinterpret_cast_</a> (const T_arg&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type, class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<br>
 <a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1static__.html">static_</a>&gt;, T_type,<br>
 typename <a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a>&lt;<br>
 T_arg &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#89e8b6d6a025937d9376edf132e369e9">static_cast_</a> (const T_arg&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type, class T_arg&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<br>
 <a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1dynamic__.html">dynamic_</a>&gt;, T_type,<br>
 typename <a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a>&lt;<br>
 T_arg &gt;::type &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#7eb410f49742a727c3292269b99771a2">dynamic_cast_</a> (const T_arg&amp; a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3, class T_type4, class T_type5, class T_type6, class T_type7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gf94761944ad0dbd50e8b933adb07db33">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt;T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__retype.html#gf94761944ad0dbd50e8b933adb07db33"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1slot.html">slot</a>&lt; T_return,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g9e7ecd809ebe0491bf96d63b34a3b7d6">retype</a> (const <a class="el" href="classsigc_1_1slot.html">slot</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g9e7ecd809ebe0491bf96d63b34a3b7d6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt;<br>
 T_return &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ge7d8cd2a8fba2a4eccf2bed45a52bcee">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt;T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ge7d8cd2a8fba2a4eccf2bed45a52bcee"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt;<br>
 T_arg1, T_return &gt;, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g43bcf770d8f32c0863ab49eca05e9e55">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt;T_arg1, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g43bcf770d8f32c0863ab49eca05e9e55"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt;<br>
 T_arg1, T_arg2, T_return &gt;,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g5132d393a612ba8e1772e637eb161d6f">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt;T_arg1, T_arg2, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g5132d393a612ba8e1772e637eb161d6f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt;<br>
 T_arg1, T_arg2, T_arg3, T_return &gt;,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g59ed197c477846291d4434a8d4362e07">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt;T_arg1, T_arg2, T_arg3, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g59ed197c477846291d4434a8d4362e07"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt;<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_return &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g9cd37b9fc31f177779032c413f4ce466">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g9cd37b9fc31f177779032c413f4ce466"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt;<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_return &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gf196464375fb0c0734bfc1bcffce32fe">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gf196464375fb0c0734bfc1bcffce32fe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt;<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_return &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g4448964acc2dfd971ee910d25aa3ef99">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g4448964acc2dfd971ee910d25aa3ef99"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt;<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7, T_return &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g1c542592832a561bf4df1de874493524">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt;T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g1c542592832a561bf4df1de874493524"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g48a60c1ad878688272cbb00ced921fff">retype</a> (const <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g48a60c1ad878688272cbb00ced921fff"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g9f3cf52bbddcd3ddb733e15a52219945">retype</a> (const <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g9f3cf52bbddcd3ddb733e15a52219945"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g997843d50341dde86ce7c710c74dcac7">retype</a> (const <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g997843d50341dde86ce7c710c74dcac7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g0e941bc2e7d8e87edf97c9ae67146f51">retype</a> (const <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g0e941bc2e7d8e87edf97c9ae67146f51"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g0bcbb850de6ec9bb6fdf9b09551fe3ac">retype</a> (const <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g0bcbb850de6ec9bb6fdf9b09551fe3ac"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g6b34718e0c0c474ec70b8f98765a13fa">retype</a> (const <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g6b34718e0c0c474ec70b8f98765a13fa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gf311f63caed67b270834ff1b0de2798d">retype</a> (const <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gf311f63caed67b270834ff1b0de2798d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gbdc6843b99c79271712131a2b325d706">retype</a> (const <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gbdc6843b99c79271712131a2b325d706"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g8f781343421e1001c500e2b312540996">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g8f781343421e1001c500e2b312540996"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g1be8e18a2d926fe05f379ee873509e13">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g1be8e18a2d926fe05f379ee873509e13"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g902b4290aa85355946c9ee5882058d2d">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g902b4290aa85355946c9ee5882058d2d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gec9accc0811f3cedbc0759c4654cb11c">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gec9accc0811f3cedbc0759c4654cb11c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga83d29e510df23a7e211b8e22e5b1a8d">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga83d29e510df23a7e211b8e22e5b1a8d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g793c00167655e1d4286f465242767af7">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g793c00167655e1d4286f465242767af7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gb9298ebcf811a129acf76b0bb992d2af">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gb9298ebcf811a129acf76b0bb992d2af"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g77342a7c9bcb31adcfadb6e4c720a76c">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g77342a7c9bcb31adcfadb6e4c720a76c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gc159359d12e988a4042fee69cdffb260">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gc159359d12e988a4042fee69cdffb260"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g54f984d1ddfce7e7f5c7ac6e8800675e">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g54f984d1ddfce7e7f5c7ac6e8800675e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g5b36de81fc3435ddb322bf14fec8c5ce">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g5b36de81fc3435ddb322bf14fec8c5ce"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g099f82b956bad114165361dbdb013a3f">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g099f82b956bad114165361dbdb013a3f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g1bfa9b820c9073a43e67231387efb850">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g1bfa9b820c9073a43e67231387efb850"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g4218faf01b8d93f6ea2064b52b7e4b6e">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g4218faf01b8d93f6ea2064b52b7e4b6e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g337271ef256315efd7b1c994e2a568f3">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g337271ef256315efd7b1c994e2a568f3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g1a64e83d052ee1fd1a25baaa45a38ccd">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g1a64e83d052ee1fd1a25baaa45a38ccd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g391a28defc597ed6434314b65c89d7b8">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g391a28defc597ed6434314b65c89d7b8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g5201341f562754629a7cba4b1ac154e6">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g5201341f562754629a7cba4b1ac154e6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g5879e194d2bbb95c19430259a34edd42">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g5879e194d2bbb95c19430259a34edd42"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g12807cc3f987b325bdb71044c74b49e5">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g12807cc3f987b325bdb71044c74b49e5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g7cfb95fa825bf1acc9c3ebbb84f5973d">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g7cfb95fa825bf1acc9c3ebbb84f5973d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g918cd0f77de9fd2c55c60eba2982e14f">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g918cd0f77de9fd2c55c60eba2982e14f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g8d495e5d373c5b155607660e2f6726f5">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g8d495e5d373c5b155607660e2f6726f5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g214e8501de3a643a551a5105c90c455d">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g214e8501de3a643a551a5105c90c455d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gca710e4d681b9c3a3fec16e5c93cbbf2">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gca710e4d681b9c3a3fec16e5c93cbbf2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g8fa17b784993d6336d779e296201cf8f">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g8fa17b784993d6336d779e296201cf8f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g97d5644de964d05ff29ed015aefdb593">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g97d5644de964d05ff29ed015aefdb593"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gc3744aaa21982dbf2612c6fd73a986d8">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gc3744aaa21982dbf2612c6fd73a986d8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g84ea407d88d6ff9f9ba8b9fcfc2ff8d9">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g84ea407d88d6ff9f9ba8b9fcfc2ff8d9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g2b705de2cb157b8f0c2691e3c2fa18a3">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g2b705de2cb157b8f0c2691e3c2fa18a3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gf17901c59027ec955d89e0429f7a5756">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gf17901c59027ec955d89e0429f7a5756"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g7287e4694beceddfa96047ddaf39a49c">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g7287e4694beceddfa96047ddaf39a49c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g2e7b340189aaab7bc618b15397572a26">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g2e7b340189aaab7bc618b15397572a26"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gcf8109a58cf43637ad16cf0820bb0134">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gcf8109a58cf43637ad16cf0820bb0134"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g36b43d5df6d755dc58d97f1263539cd3">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g36b43d5df6d755dc58d97f1263539cd3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g6a099d579a3622424c918a3cec77dd81">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g6a099d579a3622424c918a3cec77dd81"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g8c985235cd1486493399a4abc06426cc">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g8c985235cd1486493399a4abc06426cc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga65462bfe69452439634ddd50faf973f">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga65462bfe69452439634ddd50faf973f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga0b40e211a2adae5535fa3d54577c202">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga0b40e211a2adae5535fa3d54577c202"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g0ae20accd33a19a803dacbd3468ad70a">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g0ae20accd33a19a803dacbd3468ad70a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gcd0c8c77539d8b8005d02c8b337c2e01">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gcd0c8c77539d8b8005d02c8b337c2e01"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g2919261a6fddae2a22087d7750fa6a6a">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g2919261a6fddae2a22087d7750fa6a6a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g8ec506f8e3c58f9110abba3e57191274">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g8ec506f8e3c58f9110abba3e57191274"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g0e4c2986f8ecbb8e1bfa3b577378bfe5">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g0e4c2986f8ecbb8e1bfa3b577378bfe5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g1fe05d9673001d612f8c04b47cfa9df5">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g1fe05d9673001d612f8c04b47cfa9df5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga13067d1efaa9cd971e920d768491987">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga13067d1efaa9cd971e920d768491987"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g5ee85a2f76f6704283c49b427685778c">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g5ee85a2f76f6704283c49b427685778c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g0789104c19b2047210af67ecf114a0fa">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g0789104c19b2047210af67ecf114a0fa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g4f536365709d563dad97f6daae927ab1">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g4f536365709d563dad97f6daae927ab1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gf3e306d9428c5638a70bdbd727af704d">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gf3e306d9428c5638a70bdbd727af704d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gbe718b667b7a517c71b0ffe1b0396eb5">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gbe718b667b7a517c71b0ffe1b0396eb5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga5a97441232fcd3327a7074273b76dfe">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga5a97441232fcd3327a7074273b76dfe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g60c0b461a02ba132a5cb9b606f2e6a8e">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g60c0b461a02ba132a5cb9b606f2e6a8e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g2c4682e425459e38dff66336682a86af">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#g2c4682e425459e38dff66336682a86af"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;, T_arg1, T_arg2,<br>
 T_arg3, T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gfbca067a1510f64f4a592723610ce673">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gfbca067a1510f64f4a592723610ce673"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gc5243528ad5bdd95f5915b47c5c85ff6">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gc5243528ad5bdd95f5915b47c5c85ff6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gd33e9950e9acacd8d6817494f43b7f6d">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a>&lt;T_return, T_functor&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__retype.html#gd33e9950e9acacd8d6817494f43b7f6d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a>&lt; T_return,<br>
 T_functor &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#g263b14f3b0e5616cd3b870d78a2627fa">retype_return</a> (const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__return__functor.html">sigc::retype_return_functor</a> which performs a C-style cast on the return value of the passed functor.  <a href="group__retype.html#g263b14f3b0e5616cd3b870d78a2627fa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a>&lt; void,<br>
 T_functor &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#gd7e18e1edbbefe13216eb344bd522f0a">hide_return</a> (const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__return__functor.html">sigc::retype_return_functor</a> which drops the return value of the passed functor.  <a href="group__hide.html#gd7e18e1edbbefe13216eb344bd522f0a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8a0e4bdca79dde7347318bff4d6e1eda">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g8a0e4bdca79dde7347318bff4d6e1eda"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gff3264460325cf2a34cc0502fec7b8b7">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gff3264460325cf2a34cc0502fec7b8b7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g497c57551529e8721861cedc1c3d5121">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g497c57551529e8721861cedc1c3d5121"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g5cc57f71faadc4101e7a10e0b5d7317f">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g5cc57f71faadc4101e7a10e0b5d7317f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g66608a108aa332faf3c3bfd418655fcb">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g66608a108aa332faf3c3bfd418655fcb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gee9534127cddea3f7b3e5461f768a42b">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gee9534127cddea3f7b3e5461f768a42b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g259c308cca0572400aaed34384eafbe3">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g259c308cca0572400aaed34384eafbe3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g56f7d4d8f86928edb83e1f65702a2978">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g56f7d4d8f86928edb83e1f65702a2978"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga0d89783277d6e9dede11eda2ff6c75a">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#ga0d89783277d6e9dede11eda2ff6c75a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g20b2c11c8fb2a9e0bb86ad4c66c9c2e7">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g20b2c11c8fb2a9e0bb86ad4c66c9c2e7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8ef4b45b1dcecb9270562c030e38e339">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g8ef4b45b1dcecb9270562c030e38e339"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3c16c17557fcebdd7573fa6b2ed0dcf">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#ga3c16c17557fcebdd7573fa6b2ed0dcf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g6bbf2084c41ca86d2ab99e21adf28f30">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g6bbf2084c41ca86d2ab99e21adf28f30"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g21e843c71a56dba1d507c9a92fad48d1">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g21e843c71a56dba1d507c9a92fad48d1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g5af2a45e22e6f53837fa0b5f9de0ad57">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g5af2a45e22e6f53837fa0b5f9de0ad57"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf8ba948d4075a160a3c887d5bc29fe38">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gf8ba948d4075a160a3c887d5bc29fe38"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g167fc8e84727e8b465c5f569da18fe7c">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g167fc8e84727e8b465c5f569da18fe7c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc99d35f92c4859d7ba58c0f8dbee8a59">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gc99d35f92c4859d7ba58c0f8dbee8a59"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfd990e80dc9ec40599b0e66526334ed3">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gfd990e80dc9ec40599b0e66526334ed3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8df64a5ef08edf9a3bffd45888cf6566">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g8df64a5ef08edf9a3bffd45888cf6566"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g115420b91c53ff373128c8d9c5389e26">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g115420b91c53ff373128c8d9c5389e26"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g59db8f4f6bf774aac7a42e4db22fe525">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g59db8f4f6bf774aac7a42e4db22fe525"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g4fe42d39978e3534528e704a2ef69d19">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g4fe42d39978e3534528e704a2ef69d19"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ged1e318f76b0b4560f7f7f15348bf74f">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#ged1e318f76b0b4560f7f7f15348bf74f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g7f0b3a137305d0da984cfcaa69028645">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g7f0b3a137305d0da984cfcaa69028645"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfa45bea25d6b97dd4215c61845eb276b">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gfa45bea25d6b97dd4215c61845eb276b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8bbfab43840801b698deebdbcced31b8">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g8bbfab43840801b698deebdbcced31b8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g4e8a4b740ba229328323782cdff5defc">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g4e8a4b740ba229328323782cdff5defc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ge32dedba98d5616ffed3bf45564b5925">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#ge32dedba98d5616ffed3bf45564b5925"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g0a7438643be599bd0687c6de6af6ec2b">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#g0a7438643be599bd0687c6de6af6ec2b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gcb29a90ac86fe224d4074619e0117cb8">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gcb29a90ac86fe224d4074619e0117cb8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_return, class T_obj, class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa2493ee4790a02fad2dfd44e3e4e1f6">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a functor on each of the targets of a functor.  <a href="group__mem__fun.html#gaa2493ee4790a02fad2dfd44e3e4e1f6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt;T_return, T_obj&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gd6f8ec28efe46a939923e0ae83aa2888">mem_fun0</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gd6f8ec28efe46a939923e0ae83aa2888"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc54cbcf11289d7b7fe15dff1fc2e84f4">mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gc54cbcf11289d7b7fe15dff1fc2e84f4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g353bb1c7c03796bafe5ed2e52f012980">mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g353bb1c7c03796bafe5ed2e52f012980"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga603c1c92cc9140a13d89256724de663">mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.  <a href="group__mem__fun.html#ga603c1c92cc9140a13d89256724de663"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g9e5cce0968f3f2a79240922ebc1b6745">mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g9e5cce0968f3f2a79240922ebc1b6745"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb0cbec1f295cbf8283208dedf5ab9ac7">mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gb0cbec1f295cbf8283208dedf5ab9ac7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g1c9c46a46db3d5d01d582b6867665c7c">mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g1c9c46a46db3d5d01d582b6867665c7c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfb7d7c8968bebcfea74f08c3eb55b14f">mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gfb7d7c8968bebcfea74f08c3eb55b14f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ge75bc5b94c36e78775ff5b5f20767baf">mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ge75bc5b94c36e78775ff5b5f20767baf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g3d62fea84f3f77ac5a315cebe5286b47">mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g3d62fea84f3f77ac5a315cebe5286b47"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gbb30783d2b0ac099089d70274d4459fb">mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gbb30783d2b0ac099089d70274d4459fb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf19bbb21b4b903e1a6b97fea87e90663">mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gf19bbb21b4b903e1a6b97fea87e90663"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb1a00dd97f2ca5e21b2b4f73fea4053b">mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gb1a00dd97f2ca5e21b2b4f73fea4053b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga34194e868680c9146f8d143ddbdd8a8">mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga34194e868680c9146f8d143ddbdd8a8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g4908458d042d70f91be5f72547518e4f">mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g4908458d042d70f91be5f72547518e4f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g750c42aaea61ec588daf64d4111e8429">mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g750c42aaea61ec588daf64d4111e8429"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc725cb282b0c611c67a270a7821e173f">mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gc725cb282b0c611c67a270a7821e173f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g211bd1f151b5936a549a8d8e6ab911bf">mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g211bd1f151b5936a549a8d8e6ab911bf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g55aafe144e22f4df7fe785c1eec839ca">mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g55aafe144e22f4df7fe785c1eec839ca"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g3b7fd6101534e982aa29c0308ce69006">mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g3b7fd6101534e982aa29c0308ce69006"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gdedf83e65a2aca0d3aa4ac0b6d68ccd8">mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gdedf83e65a2aca0d3aa4ac0b6d68ccd8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g61cec9d9ec3d399f0d14a3b2edb6fecc">mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g61cec9d9ec3d399f0d14a3b2edb6fecc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf6a1bce5fc8d6a117124874f2fa6ab18">mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gf6a1bce5fc8d6a117124874f2fa6ab18"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g208d42856768ebe922a1418f7250ca31">mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g208d42856768ebe922a1418f7250ca31"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt;T_return, T_obj&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602">mem_fun</a> (T_return(T_obj::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj,<br>
 T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfa7e13948472a451e25485f2c5001028">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gfa7e13948472a451e25485f2c5001028"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g13a02e1edfe8b4450aba9f9629c69183">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g13a02e1edfe8b4450aba9f9629c69183"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8a171185d53c5ef87adb18bdd1d34aca">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g8a171185d53c5ef87adb18bdd1d34aca"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g17d792c86d3251c2045987c4dec04494">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g17d792c86d3251c2045987c4dec04494"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g72ce5f7bfd24897f48d0ebd676bcbe5a">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.  <a href="group__mem__fun.html#g72ce5f7bfd24897f48d0ebd676bcbe5a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gdbb4cac2850f0f61f6d5f9e17e02c7ba">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gdbb4cac2850f0f61f6d5f9e17e02c7ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj,<br>
 T_arg1, T_arg2, T_arg3, T_arg4,<br>
 T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gf995826321b8808ce8839e4abbb0550d">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.  <a href="group__mem__fun.html#gf995826321b8808ce8839e4abbb0550d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return,<br>
 T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g51fa4e5052666f6738abbaa628ec6cc2">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g51fa4e5052666f6738abbaa628ec6cc2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return,<br>
 T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ge53b7ef4bd43363998aff8a589bc254a">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ge53b7ef4bd43363998aff8a589bc254a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g47ec248386b6998e5f8b9a80191e4d5d">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g47ec248386b6998e5f8b9a80191e4d5d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g6e58e3cf7e4f1b5fbcb85736369d018c">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g6e58e3cf7e4f1b5fbcb85736369d018c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g1b200788ce261aef52a8dadaa1e2c9aa">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g1b200788ce261aef52a8dadaa1e2c9aa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g81b830d633d756ca945bac75c4b2f8e8">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g81b830d633d756ca945bac75c4b2f8e8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g975cacf1b6fdd69a93c2f5ba0973f780">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g975cacf1b6fdd69a93c2f5ba0973f780"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return,<br>
 T_obj, T_arg1, T_arg2, T_arg3,<br>
 T_arg4, T_arg5, T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb37fdbceea44a66560bb16345e1593e6">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gb37fdbceea44a66560bb16345e1593e6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;<br>
 T_return, T_obj &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gdd76171e23f2e904c7f01264228440fc">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gdd76171e23f2e904c7f01264228440fc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;<br>
 T_return, T_obj, T_arg1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g23120ad94420b72a8761423c5bab2bec">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g23120ad94420b72a8761423c5bab2bec"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g34e7257908fb33b2582f686ac51e1d74">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g34e7257908fb33b2582f686ac51e1d74"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gc41f442c5e8a533e98cce0d7df02efe6">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gc41f442c5e8a533e98cce0d7df02efe6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gb1b6c289aa5b68e382c259bb5c35aa95">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gb1b6c289aa5b68e382c259bb5c35aa95"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#g8fbf4b5621eda8f79ba2be75bd7badd4">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#g8fbf4b5621eda8f79ba2be75bd7badd4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gfc3676e579d8e7b037c0589b2ab12270">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gfc3676e579d8e7b037c0589b2ab12270"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return, class T_obj, class T_obj2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;<br>
 T_return, T_obj, T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gcdcec06e66f0ba9a970e530c953d60b6">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gcdcec06e66f0ba9a970e530c953d60b6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gd9b9e60a02af51249293093877d12366">ptr_fun0</a> (T_return(* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor0.html">sigc::pointer_functor0</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gd9b9e60a02af51249293093877d12366"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1,<br>
 T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#g0b111edc3fc4c7d7a50a715378033b1c">ptr_fun1</a> (T_return(* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor1.html">sigc::pointer_functor1</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#g0b111edc3fc4c7d7a50a715378033b1c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1,<br>
 T_arg2, T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#g38c4617287cf62ea5778bcd45e6b8413">ptr_fun2</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor2.html">sigc::pointer_functor2</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#g38c4617287cf62ea5778bcd45e6b8413"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gf25f261757e4ca8433e60c48072dd506">ptr_fun3</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor3.html">sigc::pointer_functor3</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gf25f261757e4ca8433e60c48072dd506"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gb33650945fc4148175796c0b45a26c15">ptr_fun4</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor4.html">sigc::pointer_functor4</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gb33650945fc4148175796c0b45a26c15"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gffd561d08fb54a910f5f0cea173c4bbe">ptr_fun5</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor5.html">sigc::pointer_functor5</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gffd561d08fb54a910f5f0cea173c4bbe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#g48eb020d398df8dd911ae554ee2e9887">ptr_fun6</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor6.html">sigc::pointer_functor6</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#g48eb020d398df8dd911ae554ee2e9887"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7, T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#g4678730f53d27b7a4a4eac2cae823426">ptr_fun7</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor7.html">sigc::pointer_functor7</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#g4678730f53d27b7a4a4eac2cae823426"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt;T_return&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465">ptr_fun</a> (T_return(* _A_func)())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor0.html">sigc::pointer_functor0</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gda8b678665c14dc85eb32d25b7299465"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1,<br>
 T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#g9b28ec630d156c9251de7dd12139671f">ptr_fun</a> (T_return(* _A_func)(T_arg1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor1.html">sigc::pointer_functor1</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#g9b28ec630d156c9251de7dd12139671f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1,<br>
 T_arg2, T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gc5c9c67966d9e6872ae952a1b1f96f08">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor2.html">sigc::pointer_functor2</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gc5c9c67966d9e6872ae952a1b1f96f08"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gc897cc13ff189eadb4a7577adba53e2a">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor3.html">sigc::pointer_functor3</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gc897cc13ff189eadb4a7577adba53e2a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#g825d6c1994a42e3eff13f7809b73f183">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor4.html">sigc::pointer_functor4</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#g825d6c1994a42e3eff13f7809b73f183"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#g2ad99382247bb38fcc4ff361fa4784a1">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor5.html">sigc::pointer_functor5</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#g2ad99382247bb38fcc4ff361fa4784a1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gf3efb8e32d5509d89d9e2f80e63eee1b">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor6.html">sigc::pointer_functor6</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gf3efb8e32d5509d89d9e2f80e63eee1b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_arg1, class T_arg2, class T_arg3, class T_arg4, class T_arg5, class T_arg6, class T_arg7, class T_return&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1,<br>
 T_arg2, T_arg3, T_arg4, T_arg5,<br>
 T_arg6, T_arg7, T_return &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#g8be3b4da1860c651aa63f0340af17a4e">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor7.html">sigc::pointer_functor7</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#g8be3b4da1860c651aa63f0340af17a4e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_type, bool I_derives_trackable&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#45fbeeeed09915ba6eac52d8c0e6f601">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1limit__reference.html">limit_reference</a>&lt;T_type, I_derives_trackable&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1limit__reference.html">limit_reference</a> class, to call <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> on the entity returned by the limit_reference's visit() method.  <a href="#45fbeeeed09915ba6eac52d8c0e6f601"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_type, bool I_derives_trackable&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#3d6923539508a182c7c0f2cd14f7da76">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1const__limit__reference.html">const_limit_reference</a>&lt;T_type, I_derives_trackable&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__limit__reference.html">const_limit_reference</a> class, to call <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> on the entity returned by the const_limit_reference's visit() method.  <a href="#3d6923539508a182c7c0f2cd14f7da76"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_type, bool I_derives_trackable&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#6d8d4ebf03d12349254c840b6abeab1b">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1volatile__limit__reference.html">volatile_limit_reference</a>&lt;T_type, I_derives_trackable&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1volatile__limit__reference.html">volatile_limit_reference</a> class, to call <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> on the entity returned by the volatile_limit_reference's visit() method.  <a href="#6d8d4ebf03d12349254c840b6abeab1b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_type, bool I_derives_trackable&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#0729e10eaf72affb56a48c20f7197009">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1const__volatile__limit__reference.html">const_volatile_limit_reference</a>&lt;T_type, I_derives_trackable&gt;&amp; _A_target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__volatile__limit__reference.html">const_volatile_limit_reference</a> class, to call <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> on the entity returned by the const_volatile_limit_reference's visit() method.  <a href="#0729e10eaf72affb56a48c20f7197009"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt;T_type&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#d6e63f1697c807728f518f21f69e1931">ref</a> (T_type&amp; v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a reference wrapper.  <a href="#d6e63f1697c807728f518f21f69e1931"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt;T_type&gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#70808607392abfe36e726a7d7a455b54">ref</a> (const T_type&amp; v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a const reference wrapper.  <a href="#70808607392abfe36e726a7d7a455b54"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T_type&amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#9ab34595691ae106045ce14a4c39c475">unwrap</a> (const <a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt;T_type&gt;&amp; v)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">const T_type&amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#80818400f4a09973ac095c8d59d613be">unwrap</a> (const <a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt;T_type&gt;&amp; v)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_action, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functors.html#gdab29aed05524743da16319da4430541">visit_each</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor.  <a href="group__functors.html#gdab29aed05524743da16319da4430541"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T_type, class T_action, class T_functor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functors.html#g5c455eda401dee43de931c24ad45d445">visit_each_type</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor limited to a restricted type.  <a href="group__functors.html#g5c455eda401dee43de931c24ad45d445"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select1.html">internal::lambda_select1</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesigc.html#e97b63f5ec67f39d2e69a746766872ee">_1</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select2.html">internal::lambda_select2</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesigc.html#b94262522878fd819509b356dcd99ca3">_2</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select3.html">internal::lambda_select3</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesigc.html#c33db40bd8b060e3c0da74703cba5703">_3</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select4.html">internal::lambda_select4</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2f40d3bded108703621c58d3ae80dd0f">_4</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select5.html">internal::lambda_select5</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesigc.html#db53d0a0af3c53f204c58a38168a7f61">_5</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select6.html">internal::lambda_select6</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesigc.html#2d717a76ec700fcec2b40671702d4298">_6</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select7.html">internal::lambda_select7</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesigc.html#93fcb18aeced7e1a8577ddfb4240ebb4">_7</a></td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="7eb410f49742a727c3292269b99771a2"></a><!-- doxytag: member="sigc::dynamic_cast_" ref="7eb410f49742a727c3292269b99771a2" args="(const T_arg &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type, class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1dynamic__.html">dynamic_</a>&gt;, T_type, typename <a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a>&lt;T_arg&gt;::type&gt; &gt; sigc::dynamic_cast_           </td>
          <td>(</td>
          <td class="paramtype">const T_arg &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9aee9af00f94197bed616f6a5059c491"></a><!-- doxytag: member="sigc::exception_catch" ref="9aee9af00f94197bed616f6a5059c491" args="(const T_functor &amp;_A_func, const T_catcher &amp;_A_catcher)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_functor, class T_catcher&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1exception__catch__functor.html">exception_catch_functor</a>&lt;T_functor, T_catcher&gt; sigc::exception_catch           </td>
          <td>(</td>
          <td class="paramtype">const T_functor &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_catcher &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_catcher</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="373b1216c685961b9d073e300cbda78f"></a><!-- doxytag: member="sigc::group" ref="373b1216c685961b9d073e300cbda78f" args="(const T_functor &amp;_A_func, T_type1 _A_1, T_type2 _A_2, T_type3 _A_3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_functor, class T_type1, class T_type2, class T_type3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__group3.html">lambda_group3</a>&lt;T_functor, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type1&gt;::type,typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type2&gt;::type,typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type3&gt;::type&gt; &gt; sigc::group           </td>
          <td>(</td>
          <td class="paramtype">const T_functor &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_type1&nbsp;</td>
          <td class="paramname"> <em>_A_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_type2&nbsp;</td>
          <td class="paramname"> <em>_A_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_type3&nbsp;</td>
          <td class="paramname"> <em>_A_3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="948eb594b3254c2efbe88d1dbb4d35dc"></a><!-- doxytag: member="sigc::group" ref="948eb594b3254c2efbe88d1dbb4d35dc" args="(const T_functor &amp;_A_func, T_type1 _A_1, T_type2 _A_2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_functor, class T_type1, class T_type2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__group2.html">lambda_group2</a>&lt;T_functor, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type1&gt;::type,typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type2&gt;::type&gt; &gt; sigc::group           </td>
          <td>(</td>
          <td class="paramtype">const T_functor &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_type1&nbsp;</td>
          <td class="paramname"> <em>_A_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_type2&nbsp;</td>
          <td class="paramname"> <em>_A_2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d36281e6ca158599b36980a801f41aac"></a><!-- doxytag: member="sigc::group" ref="d36281e6ca158599b36980a801f41aac" args="(const T_functor &amp;_A_func, T_type1 _A_1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_functor, class T_type1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__group1.html">lambda_group1</a>&lt;T_functor, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_type1&gt;::type&gt; &gt; sigc::group           </td>
          <td>(</td>
          <td class="paramtype">const T_functor &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_type1&nbsp;</td>
          <td class="paramname"> <em>_A_1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8d9d07ddf7ce8aec640d92b45db91309"></a><!-- doxytag: member="sigc::operator &amp;" ref="8d9d07ddf7ce8aec640d92b45db91309" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__other.html">unary_other</a>&lt;<a class="el" href="structsigc_1_1address.html">address</a>&gt;, T_arg&gt; &gt; sigc::operator&amp;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cf462bfb7b85b19e4e4308c9a27ffcc2"></a><!-- doxytag: member="sigc::operator &amp;" ref="cf462bfb7b85b19e4e4308c9a27ffcc2" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator&amp;           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c98c7424a1a331909cfe0e2a0761c18f"></a><!-- doxytag: member="sigc::operator &amp;" ref="c98c7424a1a331909cfe0e2a0761c18f" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator&amp;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="461df6e22a0f398518cba4a6d188afc9"></a><!-- doxytag: member="sigc::operator &amp;" ref="461df6e22a0f398518cba4a6d188afc9" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator&amp;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9a43e8f2ed62653f3cdd1c7fc822eac1"></a><!-- doxytag: member="sigc::operator &amp;&amp;" ref="9a43e8f2ed62653f3cdd1c7fc822eac1" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator&amp;&amp;           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="bca5b3586ae165f374e0ecda6e742368"></a><!-- doxytag: member="sigc::operator &amp;&amp;" ref="bca5b3586ae165f374e0ecda6e742368" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator&amp;&amp;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f68affa8bbefac3b556d333240a97f3e"></a><!-- doxytag: member="sigc::operator &amp;&amp;" ref="f68affa8bbefac3b556d333240a97f3e" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator&amp;&amp;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="56cab772bbbecd16ed69b0b3897d7622"></a><!-- doxytag: member="sigc::operator &amp;=" ref="56cab772bbbecd16ed69b0b3897d7622" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator&amp;=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cac27c3e543578eb522f66c1612435bb"></a><!-- doxytag: member="sigc::operator &amp;=" ref="cac27c3e543578eb522f66c1612435bb" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator&amp;=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a25d6e499bf8c44cfd04d2900ca4a156"></a><!-- doxytag: member="sigc::operator &amp;=" ref="a25d6e499bf8c44cfd04d2900ca4a156" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1and__.html">and_</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator&amp;=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="977f37aadcfd2fc5045800bdfd81cde1"></a><!-- doxytag: member="sigc::operator *" ref="977f37aadcfd2fc5045800bdfd81cde1" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__other.html">unary_other</a>&lt;<a class="el" href="structsigc_1_1dereference.html">dereference</a>&gt;, T_arg&gt; &gt; sigc::operator*           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="db9970b1407a0d915eefd423acfc2af6"></a><!-- doxytag: member="sigc::operator *" ref="db9970b1407a0d915eefd423acfc2af6" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator*           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b8250f41a97fbcaf00f38e3cdac71880"></a><!-- doxytag: member="sigc::operator *" ref="b8250f41a97fbcaf00f38e3cdac71880" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator*           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="96302d55d9f9487b85bd723983bf7dc8"></a><!-- doxytag: member="sigc::operator *" ref="96302d55d9f9487b85bd723983bf7dc8" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator*           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="db177314c99341fd5b57f65989a31e10"></a><!-- doxytag: member="sigc::operator *=" ref="db177314c99341fd5b57f65989a31e10" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator*=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4310d9b5aeb6048b08cce89273d11d9c"></a><!-- doxytag: member="sigc::operator *=" ref="4310d9b5aeb6048b08cce89273d11d9c" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator*=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f0221188780339a72bddffa5e64a24a6"></a><!-- doxytag: member="sigc::operator *=" ref="f0221188780339a72bddffa5e64a24a6" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1multiplies.html">multiplies</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator*=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1f087b34043a9ddd59fd58da582e4349"></a><!-- doxytag: member="sigc::operator!" ref="1f087b34043a9ddd59fd58da582e4349" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__logical.html">unary_logical</a>&lt;<a class="el" href="structsigc_1_1not__.html">not_</a>&gt;, T_arg&gt; &gt; sigc::operator!           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0fc828769dcf706797f1b39f88b770f9"></a><!-- doxytag: member="sigc::operator!=" ref="0fc828769dcf706797f1b39f88b770f9" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="35550c6b98eab98d75f088abb1c06f6d"></a><!-- doxytag: member="sigc::operator!=" ref="35550c6b98eab98d75f088abb1c06f6d" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2e406f67fa7336e1e6af7f2b6de89563"></a><!-- doxytag: member="sigc::operator!=" ref="2e406f67fa7336e1e6af7f2b6de89563" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1not__equal__to.html">not_equal_to</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8900336dc8fbdcc1719095a98728aa07"></a><!-- doxytag: member="sigc::operator%" ref="8900336dc8fbdcc1719095a98728aa07" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator%           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0df1bd3cac2a2bfbb43d250aec11b171"></a><!-- doxytag: member="sigc::operator%" ref="0df1bd3cac2a2bfbb43d250aec11b171" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator%           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="448f704e10cf7099d202544144257829"></a><!-- doxytag: member="sigc::operator%" ref="448f704e10cf7099d202544144257829" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator%           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c5379cb4329503d13767b738a076b157"></a><!-- doxytag: member="sigc::operator%=" ref="c5379cb4329503d13767b738a076b157" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator%=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="69bde4f0ffcf252e7b41e28c541943ba"></a><!-- doxytag: member="sigc::operator%=" ref="69bde4f0ffcf252e7b41e28c541943ba" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator%=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a22758b40768e4e1d5292711819e73f6"></a><!-- doxytag: member="sigc::operator%=" ref="a22758b40768e4e1d5292711819e73f6" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1modulus.html">modulus</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator%=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="74d41ed6e82b12e9d2079776d1381a1b"></a><!-- doxytag: member="sigc::operator+" ref="74d41ed6e82b12e9d2079776d1381a1b" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator+           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cc0c03760fce65203d5f67f23a05aee7"></a><!-- doxytag: member="sigc::operator+" ref="cc0c03760fce65203d5f67f23a05aee7" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator+           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="29d226d0e89c123a6a99df7cf7049e98"></a><!-- doxytag: member="sigc::operator+" ref="29d226d0e89c123a6a99df7cf7049e98" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator+           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e9659bd5e4dafbdbef94794ab280fd44"></a><!-- doxytag: member="sigc::operator++" ref="e9659bd5e4dafbdbef94794ab280fd44" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1pre__increment.html">pre_increment</a>&gt;, T_arg&gt; &gt; sigc::operator++           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4f0fa4bcad9e6a2f2d084ae4d0253acc"></a><!-- doxytag: member="sigc::operator+=" ref="4f0fa4bcad9e6a2f2d084ae4d0253acc" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator+=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="334380d2c5ffd5febefb5aa0bfc6d162"></a><!-- doxytag: member="sigc::operator+=" ref="334380d2c5ffd5febefb5aa0bfc6d162" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator+=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e4450395ac4750ab095b170da8dfc0a0"></a><!-- doxytag: member="sigc::operator+=" ref="e4450395ac4750ab095b170da8dfc0a0" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1plus.html">plus</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator+=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a1e0215bf7c7cec50a46b4fbc5e09f88"></a><!-- doxytag: member="sigc::operator-" ref="a1e0215bf7c7cec50a46b4fbc5e09f88" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1negate.html">negate</a>&gt;, T_arg&gt; &gt; sigc::operator-           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="000e30854e2ad97c82db1c8e55ae9c58"></a><!-- doxytag: member="sigc::operator-" ref="000e30854e2ad97c82db1c8e55ae9c58" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator-           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ebf7d41a285af52c58329c66183aca15"></a><!-- doxytag: member="sigc::operator-" ref="ebf7d41a285af52c58329c66183aca15" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator-           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="26c54de4f570705ef709f745a1ded9c7"></a><!-- doxytag: member="sigc::operator-" ref="26c54de4f570705ef709f745a1ded9c7" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator-           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="979840b7fcd28955b01524d2d352a731"></a><!-- doxytag: member="sigc::operator--" ref="979840b7fcd28955b01524d2d352a731" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__arithmetic.html">unary_arithmetic</a>&lt;<a class="el" href="structsigc_1_1pre__decrement.html">pre_decrement</a>&gt;, T_arg&gt; &gt; sigc::operator--           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3f5f33195e31cf10b663d60bee6624be"></a><!-- doxytag: member="sigc::operator-=" ref="3f5f33195e31cf10b663d60bee6624be" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator-=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="098d8644120cfbecfce6c2fdf3dcf4fe"></a><!-- doxytag: member="sigc::operator-=" ref="098d8644120cfbecfce6c2fdf3dcf4fe" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator-=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="053d463f15272d949eddd17c1eb6057c"></a><!-- doxytag: member="sigc::operator-=" ref="053d463f15272d949eddd17c1eb6057c" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1minus.html">minus</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator-=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="778da0346854b55c0605811e427f7ece"></a><!-- doxytag: member="sigc::operator/" ref="778da0346854b55c0605811e427f7ece" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator/           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="04d7fd3f8ecfe2ace16a5f03c318a56d"></a><!-- doxytag: member="sigc::operator/" ref="04d7fd3f8ecfe2ace16a5f03c318a56d" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator/           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2cd49ce61ca95eef20291ceaaa14f7f3"></a><!-- doxytag: member="sigc::operator/" ref="2cd49ce61ca95eef20291ceaaa14f7f3" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic.html">arithmetic</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator/           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="91c8284788f629046b289b1b8bb92fd2"></a><!-- doxytag: member="sigc::operator/=" ref="91c8284788f629046b289b1b8bb92fd2" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator/=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="190f94964b496b4389ff0695459c97f2"></a><!-- doxytag: member="sigc::operator/=" ref="190f94964b496b4389ff0695459c97f2" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator/=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8749ada1d603fb667f3170e056c3d3fe"></a><!-- doxytag: member="sigc::operator/=" ref="8749ada1d603fb667f3170e056c3d3fe" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1arithmetic__assign.html">arithmetic_assign</a>&lt;<a class="el" href="structsigc_1_1divides.html">divides</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator/=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e84ae7410cde285a4062beec3f2581dd"></a><!-- doxytag: member="sigc::operator&lt;" ref="e84ae7410cde285a4062beec3f2581dd" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less.html">less</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a0f064417347c15e6c2eee46645f4b58"></a><!-- doxytag: member="sigc::operator&lt;" ref="a0f064417347c15e6c2eee46645f4b58" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less.html">less</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="64587ad0e3a569be542d546b9b1d9829"></a><!-- doxytag: member="sigc::operator&lt;" ref="64587ad0e3a569be542d546b9b1d9829" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less.html">less</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="15266193ad2aad0a0b5c77b9d54f778e"></a><!-- doxytag: member="sigc::operator&lt;&lt;" ref="15266193ad2aad0a0b5c77b9d54f778e" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="43931fdef62a0517ba0924de2f82d0a9"></a><!-- doxytag: member="sigc::operator&lt;&lt;" ref="43931fdef62a0517ba0924de2f82d0a9" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2be0aea0eb8880432737d42fa166a226"></a><!-- doxytag: member="sigc::operator&lt;&lt;" ref="2be0aea0eb8880432737d42fa166a226" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a3c8ebf217044832c473285315d0c978"></a><!-- doxytag: member="sigc::operator&lt;&lt;=" ref="a3c8ebf217044832c473285315d0c978" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator&lt;&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7d37efde4fa6742ef6090076ffde6d26"></a><!-- doxytag: member="sigc::operator&lt;&lt;=" ref="7d37efde4fa6742ef6090076ffde6d26" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator&lt;&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="717ad3389bb00a107750f9134d6170ef"></a><!-- doxytag: member="sigc::operator&lt;&lt;=" ref="717ad3389bb00a107750f9134d6170ef" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1leftshift.html">leftshift</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator&lt;&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4a9e25129fc0832aa465ce7ec679a1be"></a><!-- doxytag: member="sigc::operator&lt;=" ref="4a9e25129fc0832aa465ce7ec679a1be" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less__equal.html">less_equal</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ffb5949de125154ba78a9fab53e5c88f"></a><!-- doxytag: member="sigc::operator&lt;=" ref="ffb5949de125154ba78a9fab53e5c88f" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less__equal.html">less_equal</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="276ae53620c9234c7964816aa94ba476"></a><!-- doxytag: member="sigc::operator&lt;=" ref="276ae53620c9234c7964816aa94ba476" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1less__equal.html">less_equal</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="934ffbd686558b72a1ee12e4d9207a93"></a><!-- doxytag: member="sigc::operator==" ref="934ffbd686558b72a1ee12e4d9207a93" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1equal__to.html">equal_to</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator==           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6a642d0f9179d581a95ac21ad10003b5"></a><!-- doxytag: member="sigc::operator==" ref="6a642d0f9179d581a95ac21ad10003b5" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1equal__to.html">equal_to</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator==           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3d4a437822ac13a0b06f8d629f162441"></a><!-- doxytag: member="sigc::operator==" ref="3d4a437822ac13a0b06f8d629f162441" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1equal__to.html">equal_to</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator==           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="56f75748c8b6018401b8f82a93f29a58"></a><!-- doxytag: member="sigc::operator&gt;" ref="56f75748c8b6018401b8f82a93f29a58" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater.html">greater</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator&gt;           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="aed6caf81d925870fbc306ecaf562a9a"></a><!-- doxytag: member="sigc::operator&gt;" ref="aed6caf81d925870fbc306ecaf562a9a" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater.html">greater</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator&gt;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="82df52344c1995f4b7f66efa2c6dd1e1"></a><!-- doxytag: member="sigc::operator&gt;" ref="82df52344c1995f4b7f66efa2c6dd1e1" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater.html">greater</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator&gt;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8783dd0b543f6b51467ec1256a694174"></a><!-- doxytag: member="sigc::operator&gt;=" ref="8783dd0b543f6b51467ec1256a694174" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="109def8701355bae896321317c9fbda3"></a><!-- doxytag: member="sigc::operator&gt;=" ref="109def8701355bae896321317c9fbda3" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e1c71b2dfbafd2701d1ee7be0a5c603b"></a><!-- doxytag: member="sigc::operator&gt;=" ref="e1c71b2dfbafd2701d1ee7be0a5c603b" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1relational.html">relational</a>&lt;<a class="el" href="structsigc_1_1greater__equal.html">greater_equal</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="961c52af18d38be10448d6305875ec42"></a><!-- doxytag: member="sigc::operator&gt;&gt;" ref="961c52af18d38be10448d6305875ec42" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator&gt;&gt;           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5d32e408b09d4b18017401a618deca22"></a><!-- doxytag: member="sigc::operator&gt;&gt;" ref="5d32e408b09d4b18017401a618deca22" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator&gt;&gt;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f82dddd5da2b904553cac0cbe28fbdef"></a><!-- doxytag: member="sigc::operator&gt;&gt;" ref="f82dddd5da2b904553cac0cbe28fbdef" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator&gt;&gt;           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="77622d65d029ad3e13ed40e5c6506195"></a><!-- doxytag: member="sigc::operator&gt;&gt;=" ref="77622d65d029ad3e13ed40e5c6506195" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator&gt;&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="898e016d767b6caa5dbf55b2df889524"></a><!-- doxytag: member="sigc::operator&gt;&gt;=" ref="898e016d767b6caa5dbf55b2df889524" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator&gt;&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="002b4794715b5156dd45588364e52263"></a><!-- doxytag: member="sigc::operator&gt;&gt;=" ref="002b4794715b5156dd45588364e52263" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1rightshift.html">rightshift</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator&gt;&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="455402cbd5b9af2923150b24f1b586ed"></a><!-- doxytag: member="sigc::operator^" ref="455402cbd5b9af2923150b24f1b586ed" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator^           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f5b039f488caaf8422ce7e04f8d22fd2"></a><!-- doxytag: member="sigc::operator^" ref="f5b039f488caaf8422ce7e04f8d22fd2" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator^           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9bd6e35894b866758aa37ec441e46c1b"></a><!-- doxytag: member="sigc::operator^" ref="9bd6e35894b866758aa37ec441e46c1b" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator^           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a1f413cd83d012ce882fcb2654bd9ca2"></a><!-- doxytag: member="sigc::operator^=" ref="a1f413cd83d012ce882fcb2654bd9ca2" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator^=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9fa6e2ff33616025e04285d6ad985b87"></a><!-- doxytag: member="sigc::operator^=" ref="9fa6e2ff33616025e04285d6ad985b87" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator^=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2108c7da0f2be4495e270b156f30cedd"></a><!-- doxytag: member="sigc::operator^=" ref="2108c7da0f2be4495e270b156f30cedd" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1xor__.html">xor_</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator^=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2298b1d7394469e603ef17122d29e2c5"></a><!-- doxytag: member="sigc::operator|" ref="2298b1d7394469e603ef17122d29e2c5" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator|           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="79c58fce0596a170e3eb32aa589aa573"></a><!-- doxytag: member="sigc::operator|" ref="79c58fce0596a170e3eb32aa589aa573" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator|           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7d613863e01f8cf39a3f7a67be586b37"></a><!-- doxytag: member="sigc::operator|" ref="7d613863e01f8cf39a3f7a67be586b37" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise.html">bitwise</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator|           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5a32da57863bbe61bca7ef039e1e6c3a"></a><!-- doxytag: member="sigc::operator|=" ref="5a32da57863bbe61bca7ef039e1e6c3a" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator|=           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="38281683e4f30ae38ebd9a77acadd68c"></a><!-- doxytag: member="sigc::operator|=" ref="38281683e4f30ae38ebd9a77acadd68c" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator|=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="188bc271d74500df8b312869b7db9100"></a><!-- doxytag: member="sigc::operator|=" ref="188bc271d74500df8b312869b7db9100" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1bitwise__assign.html">bitwise_assign</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator|=           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b185848c59fea219a747cb1009f1c881"></a><!-- doxytag: member="sigc::operator||" ref="b185848c59fea219a747cb1009f1c881" args="(const T_arg1 &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg1&gt;::type, T_arg2&gt; &gt; sigc::operator||           </td>
          <td>(</td>
          <td class="paramtype">const T_arg1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="be7b14c8d37e24cc62259aba382f5b3e"></a><!-- doxytag: member="sigc::operator||" ref="be7b14c8d37e24cc62259aba382f5b3e" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const T_arg2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, typename <a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt;T_arg2&gt;::type&gt; &gt; sigc::operator||           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_arg2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5c4eea4d6cfb47d019091f7b64177dcc"></a><!-- doxytag: member="sigc::operator||" ref="5c4eea4d6cfb47d019091f7b64177dcc" args="(const lambda&lt; T_arg1 &gt; &amp;a1, const lambda&lt; T_arg2 &gt; &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator.html">lambda_operator</a>&lt;<a class="el" href="structsigc_1_1logical.html">logical</a>&lt;<a class="el" href="structsigc_1_1or__.html">or_</a>&gt;, T_arg1, T_arg2&gt; &gt; sigc::operator||           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="db7ab85e9d37fd0d23e68c39d4c9f7ae"></a><!-- doxytag: member="sigc::operator~" ref="db7ab85e9d37fd0d23e68c39d4c9f7ae" args="(const lambda&lt; T_arg &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator__unary.html">lambda_operator_unary</a>&lt;<a class="el" href="structsigc_1_1unary__bitwise.html">unary_bitwise</a>&lt;<a class="el" href="structsigc_1_1not__.html">not_</a>&gt;, T_arg&gt; &gt; sigc::operator~           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_arg &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="70808607392abfe36e726a7d7a455b54"></a><!-- doxytag: member="sigc::ref" ref="70808607392abfe36e726a7d7a455b54" args="(const T_type &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt;T_type&gt; sigc::ref           </td>
          <td>(</td>
          <td class="paramtype">const T_type &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a const reference wrapper. 
<p>
Passing an object throught <a class="el" href="namespacesigc.html#d6e63f1697c807728f518f21f69e1931">sigc::ref()</a> makes libsigc++ adaptors like, e.g., <a class="el" href="group__bind.html#g2148290d2cf9c1961ec157a085badd5a">sigc::bind</a> store references to the object instead of copies. If the object type inherits from <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> this will ensure automatic invalidation of the adaptors when the object is deleted or overwritten.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Reference to store. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference wrapper. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d6e63f1697c807728f518f21f69e1931"></a><!-- doxytag: member="sigc::ref" ref="d6e63f1697c807728f518f21f69e1931" args="(T_type &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt;T_type&gt; sigc::ref           </td>
          <td>(</td>
          <td class="paramtype">T_type &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a reference wrapper. 
<p>
Passing an object throught <a class="el" href="namespacesigc.html#d6e63f1697c807728f518f21f69e1931">sigc::ref()</a> makes libsigc++ adaptors like, e.g., <a class="el" href="group__bind.html#g2148290d2cf9c1961ec157a085badd5a">sigc::bind</a> store references to the object instead of copies. If the object type inherits from <a class="el" href="structsigc_1_1trackable.html">sigc::trackable</a> this will ensure automatic invalidation of the adaptors when the object is deleted or overwritten.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Reference to store. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference wrapper. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ba07befc70db9c92da9a0ba298b7c4e"></a><!-- doxytag: member="sigc::reinterpret_cast_" ref="0ba07befc70db9c92da9a0ba298b7c4e" args="(const T_arg &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type, class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1reinterpret__.html">reinterpret_</a>&gt;, T_type, typename <a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a>&lt;T_arg&gt;::type&gt; &gt; sigc::reinterpret_cast_           </td>
          <td>(</td>
          <td class="paramtype">const T_arg &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="89e8b6d6a025937d9376edf132e369e9"></a><!-- doxytag: member="sigc::static_cast_" ref="89e8b6d6a025937d9376edf132e369e9" args="(const T_arg &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type, class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1lambda__operator__convert.html">lambda_operator_convert</a>&lt;<a class="el" href="structsigc_1_1cast__.html">cast_</a>&lt;<a class="el" href="structsigc_1_1static__.html">static_</a>&gt;, T_type, typename <a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a>&lt;T_arg&gt;::type&gt; &gt; sigc::static_cast_           </td>
          <td>(</td>
          <td class="paramtype">const T_arg &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="80818400f4a09973ac095c8d59d613be"></a><!-- doxytag: member="sigc::unwrap" ref="80818400f4a09973ac095c8d59d613be" args="(const const_reference_wrapper&lt; T_type &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T_type&amp; sigc::unwrap           </td>
          <td>(</td>
          <td class="paramtype">const const_reference_wrapper&lt; T_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9ab34595691ae106045ce14a4c39c475"></a><!-- doxytag: member="sigc::unwrap" ref="9ab34595691ae106045ce14a4c39c475" args="(const reference_wrapper&lt; T_type &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T_type&amp; sigc::unwrap           </td>
          <td>(</td>
          <td class="paramtype">const reference_wrapper&lt; T_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="55f65aefeb2254213ed4149610c58e16"></a><!-- doxytag: member="sigc::unwrap_lambda_value" ref="55f65aefeb2254213ed4149610c58e16" args="(const lambda&lt; T_type &gt; &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T_type&amp; sigc::unwrap_lambda_value           </td>
          <td>(</td>
          <td class="paramtype">const lambda&lt; T_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6d9b97698fd134e2ec1e103fbe893b07"></a><!-- doxytag: member="sigc::unwrap_lambda_value" ref="6d9b97698fd134e2ec1e103fbe893b07" args="(const T_type &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T_type&amp; sigc::unwrap_lambda_value           </td>
          <td>(</td>
          <td class="paramtype">const T_type &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="72c9f563f8d97738fa8d3d494e0ff0f5"></a><!-- doxytag: member="sigc::unwrap_lambda_value" ref="72c9f563f8d97738fa8d3d494e0ff0f5" args="(T_type &amp;a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T_type&amp; sigc::unwrap_lambda_value           </td>
          <td>(</td>
          <td class="paramtype">T_type &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the object stored inside a lambda object. 
<p>
Returns the object passed as argument if it is not of type lambda. 
</div>
</div><p>
<a class="anchor" name="d0f037b8944e6c5828ccbffa28726525"></a><!-- doxytag: member="sigc::var" ref="d0f037b8944e6c5828ccbffa28726525" args="(const T_type &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;const T_type&amp;&gt; sigc::var           </td>
          <td>(</td>
          <td class="paramtype">const T_type &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a constant reference into a lambda object. 
<p>

</div>
</div><p>
<a class="anchor" name="a354a134fa27b2dc8295af1c871b5885"></a><!-- doxytag: member="sigc::var" ref="a354a134fa27b2dc8295af1c871b5885" args="(T_type &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_type&amp;&gt; sigc::var           </td>
          <td>(</td>
          <td class="paramtype">T_type &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a reference into a lambda object. 
<p>
<a class="el" href="namespacesigc.html#a354a134fa27b2dc8295af1c871b5885">sigc::var</a> creates a 0-ary functor, returning the value of a referenced variable.<p>
<dl class="user" compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv)
   {
     <span class="keywordtype">int</span> data;
     <a class="code" href="classsigc_1_1signal.html">sigc::signal&lt;int&gt;</a> readValue;

     readValue.<a class="code" href="classsigc_1_1signal7.html#dc55ac9b0f935fd87a67904022e03cb2">connect</a>(<a class="code" href="namespacesigc.html#a354a134fa27b2dc8295af1c871b5885">sigc::var</a>(data));

     data = 3;
     std::cout &lt;&lt; readValue() &lt;&lt; std::endl; <span class="comment">//Prints 3.</span>

    data = 5;
    std::cout &lt;&lt; readValue() &lt;&lt; std::endl; <span class="comment">//Prints 5.</span>
   }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0729e10eaf72affb56a48c20f7197009"></a><!-- doxytag: member="sigc::visit_each" ref="0729e10eaf72affb56a48c20f7197009" args="(const T_action &amp;_A_action, const const_volatile_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_type, bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_volatile_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementation of <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__volatile__limit__reference.html">const_volatile_limit_reference</a> class, to call <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> on the entity returned by the const_volatile_limit_reference's visit() method. 
<p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li><li><em>T_type</em> The type of the reference. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_action</em>&nbsp;</td><td>The functor to invoke. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_argument</em>&nbsp;</td><td>The visited instance. </td></tr>
  </table>
</dl>
</li></ul>

</div>
</div><p>
<a class="anchor" name="6d8d4ebf03d12349254c840b6abeab1b"></a><!-- doxytag: member="sigc::visit_each" ref="6d8d4ebf03d12349254c840b6abeab1b" args="(const T_action &amp;_A_action, const volatile_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_type, bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementation of <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1volatile__limit__reference.html">volatile_limit_reference</a> class, to call <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> on the entity returned by the volatile_limit_reference's visit() method. 
<p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li><li><em>T_type</em> The type of the reference. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_action</em>&nbsp;</td><td>The functor to invoke. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_argument</em>&nbsp;</td><td>The visited instance. </td></tr>
  </table>
</dl>
</li></ul>

</div>
</div><p>
<a class="anchor" name="3d6923539508a182c7c0f2cd14f7da76"></a><!-- doxytag: member="sigc::visit_each" ref="3d6923539508a182c7c0f2cd14f7da76" args="(const T_action &amp;_A_action, const const_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_type, bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementation of <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__limit__reference.html">const_limit_reference</a> class, to call <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> on the entity returned by the const_limit_reference's visit() method. 
<p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li><li><em>T_type</em> The type of the reference. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_action</em>&nbsp;</td><td>The functor to invoke. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_argument</em>&nbsp;</td><td>The visited instance. </td></tr>
  </table>
</dl>
</li></ul>

</div>
</div><p>
<a class="anchor" name="45fbeeeed09915ba6eac52d8c0e6f601"></a><!-- doxytag: member="sigc::visit_each" ref="45fbeeeed09915ba6eac52d8c0e6f601" args="(const T_action &amp;_A_action, const limit_reference&lt; T_type, I_derives_trackable &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_type, bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementation of <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1limit__reference.html">limit_reference</a> class, to call <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> on the entity returned by the limit_reference's visit() method. 
<p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li><li><em>T_type</em> The type of the reference. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_action</em>&nbsp;</td><td>The functor to invoke. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_argument</em>&nbsp;</td><td>The visited instance. </td></tr>
  </table>
</dl>
</li></ul>

</div>
</div><p>
<a class="anchor" name="3413af839d2a7c15cbcd24e5d3098542"></a><!-- doxytag: member="sigc::visit_each" ref="3413af839d2a7c15cbcd24e5d3098542" args="(const T_action &amp;_A_action, const lambda_operator_convert&lt; T_lambda_action, T_type, T_arg &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_lambda_action, class T_type, class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda_operator_convert&lt; T_lambda_action, T_type, T_arg &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="63a15030d38a903406a7f0e3b4ef220a"></a><!-- doxytag: member="sigc::visit_each" ref="63a15030d38a903406a7f0e3b4ef220a" args="(const T_action &amp;_A_action, const lambda_operator_unary&lt; T_lambda_action, T_arg &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_lambda_action, class T_arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda_operator_unary&lt; T_lambda_action, T_arg &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="eff5a0299fefc2899b6a920ec35539b1"></a><!-- doxytag: member="sigc::visit_each" ref="eff5a0299fefc2899b6a920ec35539b1" args="(const T_action &amp;_A_action, const lambda_operator&lt;T_lambda_action, T_arg1, T_arg2 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_lambda_action, class T_arg1, class T_arg2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda_operator&lt;T_lambda_action, T_arg1, T_arg2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="93983affe370fea0a52fe7f8f47ff7ba"></a><!-- doxytag: member="sigc::visit_each" ref="93983affe370fea0a52fe7f8f47ff7ba" args="(const T_action &amp;_A_action, const lambda_group3&lt; T_functor, T_type1, T_type2, T_type3 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_functor, class T_type1, class T_type2, class T_type3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda_group3&lt; T_functor, T_type1, T_type2, T_type3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3c1afe7cb631539be654133b0c1b35fc"></a><!-- doxytag: member="sigc::visit_each" ref="3c1afe7cb631539be654133b0c1b35fc" args="(const T_action &amp;_A_action, const lambda_group2&lt; T_functor, T_type1, T_type2 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_functor, class T_type1, class T_type2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda_group2&lt; T_functor, T_type1, T_type2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f281160792e31db1dac80bc28a932ce9"></a><!-- doxytag: member="sigc::visit_each" ref="f281160792e31db1dac80bc28a932ce9" args="(const T_action &amp;_A_action, const lambda_group1&lt; T_functor, T_type1 &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_functor, class T_type1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda_group1&lt; T_functor, T_type1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6df6801c9173642c618ac337112bb2b7"></a><!-- doxytag: member="sigc::visit_each" ref="6df6801c9173642c618ac337112bb2b7" args="(const T_action &amp;_A_action, const lambda&lt; T_type &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lambda&lt; T_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c14e861d541fd6172fd66bd96b79d3c1"></a><!-- doxytag: member="sigc::visit_each" ref="c14e861d541fd6172fd66bd96b79d3c1" args="(const T_action &amp;_A_action, const internal::lambda_core&lt; T_functor, I_islambda &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_functor, bool I_islambda&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::lambda_core&lt; T_functor, I_islambda &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a223e54f7b85d4234b330a1c8502b6ba"></a><!-- doxytag: member="sigc::visit_each" ref="a223e54f7b85d4234b330a1c8502b6ba" args="(const T_action &amp;_A_action, const exception_catch_functor&lt; T_functor, T_catcher, T_return &gt; &amp;_A_target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_functor, class T_catcher, class T_return&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const exception_catch_functor&lt; T_functor, T_catcher, T_return &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="78af6ff8fb24c17f5e72fd36d0be7975"></a><!-- doxytag: member="sigc::visit_each" ref="78af6ff8fb24c17f5e72fd36d0be7975" args="(const T_action &amp;_A_action, const bound_argument&lt; T_type &gt; &amp;_A_argument)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action, class T_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each           </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_argument&lt; T_type &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_A_argument</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementation of <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a> class. 
<p>
Call <a class="el" href="group__adaptors.html#gfb822cac23e9bf97c164793a36246d5c">visit_each()</a> on the entity returned by the bound_argument's visit() method. <em>T_action</em> The type of functor to invoke. <em>T_type</em> The type of <a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_action</em>&nbsp;</td><td>The functor to invoke. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_argument</em>&nbsp;</td><td>The visited instance. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="e97b63f5ec67f39d2e69a746766872ee"></a><!-- doxytag: member="sigc::_1" ref="e97b63f5ec67f39d2e69a746766872ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select1.html">internal::lambda_select1</a>&gt; <a class="el" href="namespacesigc.html#e97b63f5ec67f39d2e69a746766872ee">sigc::_1</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b94262522878fd819509b356dcd99ca3"></a><!-- doxytag: member="sigc::_2" ref="b94262522878fd819509b356dcd99ca3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select2.html">internal::lambda_select2</a>&gt; <a class="el" href="namespacesigc.html#b94262522878fd819509b356dcd99ca3">sigc::_2</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c33db40bd8b060e3c0da74703cba5703"></a><!-- doxytag: member="sigc::_3" ref="c33db40bd8b060e3c0da74703cba5703" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select3.html">internal::lambda_select3</a>&gt; <a class="el" href="namespacesigc.html#c33db40bd8b060e3c0da74703cba5703">sigc::_3</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2f40d3bded108703621c58d3ae80dd0f"></a><!-- doxytag: member="sigc::_4" ref="2f40d3bded108703621c58d3ae80dd0f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select4.html">internal::lambda_select4</a>&gt; <a class="el" href="namespacesigc.html#2f40d3bded108703621c58d3ae80dd0f">sigc::_4</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="db53d0a0af3c53f204c58a38168a7f61"></a><!-- doxytag: member="sigc::_5" ref="db53d0a0af3c53f204c58a38168a7f61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select5.html">internal::lambda_select5</a>&gt; <a class="el" href="namespacesigc.html#db53d0a0af3c53f204c58a38168a7f61">sigc::_5</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2d717a76ec700fcec2b40671702d4298"></a><!-- doxytag: member="sigc::_6" ref="2d717a76ec700fcec2b40671702d4298" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select6.html">internal::lambda_select6</a>&gt; <a class="el" href="namespacesigc.html#2d717a76ec700fcec2b40671702d4298">sigc::_6</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="93fcb18aeced7e1a8577ddfb4240ebb4"></a><!-- doxytag: member="sigc::_7" ref="93fcb18aeced7e1a8577ddfb4240ebb4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIGC_API const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;<a class="el" href="structsigc_1_1internal_1_1lambda__select7.html">internal::lambda_select7</a>&gt; <a class="el" href="namespacesigc.html#93fcb18aeced7e1a8577ddfb4240ebb4">sigc::_7</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.1 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
