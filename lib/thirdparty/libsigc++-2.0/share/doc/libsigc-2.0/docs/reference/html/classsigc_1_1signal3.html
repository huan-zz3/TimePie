<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libsigc++ 2.0: sigc::signal3&lt; T_return, T_arg1, T_arg2, T_arg3, T_accumulator &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/libsigc_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="../../index.html">Main Page</a> &nbsp;
  <a class="qindex" href="modules.html">Groups</a> &nbsp;
  <a class="qindex" href="namespaces.html"> Namespaces</a> &nbsp;
</center>
<hr width="100%"/>

<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="namespacesigc.html">sigc</a>::<a class="el" href="classsigc_1_1signal3.html">signal3</a></div>
<h1>sigc::signal3&lt; T_return, T_arg1, T_arg2, T_arg3, T_accumulator &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__signal.html">Signals</a>]</small>
</h1><!-- doxytag: class="sigc::signal3" --><!-- doxytag: inherits="sigc::signal_base" -->Signal declaration.  
<a href="#_details">More...</a>
<p>
Inheritance diagram for sigc::signal3&lt; T_return, T_arg1, T_arg2, T_arg3, T_accumulator &gt;:<p><center><img src="classsigc_1_1signal3__inherit__graph.png" border="0" usemap="#sigc_1_1signal3_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__accumulator_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="sigc_1_1signal3_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__accumulator_01_4__inherit__map">
<area href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01852c349c390cefa04662a850d84c0a94.html" shape="rect" coords="5,239,504,265" alt="">
<area href="structsigc_1_1signal__base.html" shape="rect" coords="192,84,317,111" alt="">
<area href="structsigc_1_1trackable.html" shape="rect" coords="199,7,311,33" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classsigc_1_1signal3-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsigc_1_1internal_1_1signal__emit3.html">internal::signal_emit3</a>&lt;<br>
 T_return, T_arg1, T_arg2,<br>
 T_arg3, T_accumulator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#ce9f45a4ff22a06f3b8edb5a6c06a70b">emitter_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsigc_1_1internal_1_1signal__emit3.html#a3e7b467c2841d5110960382bb0deca3">emitter_type::result_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#57c79755fc4c4b04196a9bf6742a0cc6">result_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classsigc_1_1slot.html">slot</a>&lt; T_return, T_arg1,<br>
 T_arg2, T_arg3 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#49c13da0a30318464062f5b26ff87979">slot_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsigc_1_1slot__list.html">slot_list</a>&lt;<a class="el" href="classsigc_1_1slot.html">slot_type</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#3bc0616e7ac933e702a889a2a84e92d4">slot_list_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsigc_1_1slot__iterator.html">slot_list_type::iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#8029a48126a2018947a2b6680ddabe6b">iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsigc_1_1slot__const__iterator.html">slot_list_type::const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#60e1ef95f82cd8981d61576d1e3f8e94">const_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsigc_1_1slot__list.html#ddb44a7590825f917b3fcf0179fadadb">slot_list_type::reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#cc453f0d5fc7f277494b2d6e737f6f68">reverse_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structsigc_1_1slot__list.html#8293bfca54539958326f57375e4d8c14">slot_list_type::const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#4ba3eb58c4c5ac2c25f49c48fd0af264">const_reverse_iterator</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1slot__iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#3eae0b3796b2736be847f33a5124aacd">connect</a> (const <a class="el" href="classsigc_1_1slot.html">slot_type</a>&amp; slot_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a slot to the list of slots.  <a href="#3eae0b3796b2736be847f33a5124aacd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1signal3.html#57c79755fc4c4b04196a9bf6742a0cc6">result_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit</a> (typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take _A_a1, typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take _A_a2, typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg3&gt;::take _A_a3) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triggers the emission of the signal.  <a href="#e761fdcaa7de4d03db68dc6312b5ccdc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1signal3.html#57c79755fc4c4b04196a9bf6742a0cc6">result_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#cdf13dffd7d65b6000ef4003881e86dd">emit_reverse</a> (typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take _A_a1, typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take _A_a2, typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg3&gt;::take _A_a3) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triggers the emission of the signal in reverse order (see <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a>).  <a href="#cdf13dffd7d65b6000ef4003881e86dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1signal3.html#57c79755fc4c4b04196a9bf6742a0cc6">result_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#31e50c09c7227a8e5dc3cecb52de9631">operator()</a> (typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take _A_a1, typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take _A_a2, typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg3&gt;::take _A_a3) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Triggers the emission of the signal (see <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a>).  <a href="#31e50c09c7227a8e5dc3cecb52de9631"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;<br>
 <a class="el" href="classsigc_1_1signal3.html#57c79755fc4c4b04196a9bf6742a0cc6">result_type</a>, <a class="el" href="classsigc_1_1signal3.html">signal3</a>, typename <br>
<a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take,<br>
 typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt; T_arg2 <br>
&gt;::take, typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;<br>
 T_arg3 &gt;::take &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#722230eba756857076043d3d4abebfc9">make_slot</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a functor that calls <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a> on this signal.  <a href="#722230eba756857076043d3d4abebfc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsigc_1_1slot__list.html">slot_list_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#b9606b708078956a758b81503f956bee">slots</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an STL-style interface for the signal's list of slots.  <a href="#b9606b708078956a758b81503f956bee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="structsigc_1_1slot__list.html">slot_list_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#742eb282312187bf8ee6992df1114781">slots</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an STL-style interface for the signal's list of slots.  <a href="#742eb282312187bf8ee6992df1114781"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#52731959f272612fd6abfe8850c5c8cf">signal3</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html#fe2c4320927b403b011a2538317e6c70">signal3</a> (const <a class="el" href="classsigc_1_1signal3.html">signal3</a>&amp; src)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt;<br>
 class sigc::signal3&lt; T_return, T_arg1, T_arg2, T_arg3, T_accumulator &gt;</h3>

Signal declaration. 
<p>
<a class="el" href="classsigc_1_1signal3.html">signal3</a> can be used to <a class="el" href="classsigc_1_1signal3.html#3eae0b3796b2736be847f33a5124aacd">connect()</a> slots that are invoked during subsequent calls to <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a>. Any functor or slot can be passed into <a class="el" href="classsigc_1_1signal3.html#3eae0b3796b2736be847f33a5124aacd">connect()</a>. It is converted into a slot implicitely.<p>
If you want to connect one signal to another, use <a class="el" href="classsigc_1_1signal3.html#722230eba756857076043d3d4abebfc9">make_slot()</a> to retrieve a functor that emits the signal when invoked.<p>
Be careful if you directly pass one signal into the <a class="el" href="classsigc_1_1signal3.html#3eae0b3796b2736be847f33a5124aacd">connect()</a> method of another: a shallow copy of the signal is made and the signal's slots are not disconnected until both the signal and its clone are destroyed which is probably not what you want!<p>
An STL-style list interface for the signal's list of slots can be retrieved with <a class="el" href="classsigc_1_1signal3.html#b9606b708078956a758b81503f956bee">slots()</a>. This interface supports iteration, insertion and removal of slots.<p>
The following template arguments are used:<ul>
<li><em>T_return</em> The desired return type for the <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a> function (may be overridden by the accumulator).</li><li><em>T_arg1</em> Argument type used in the definition of <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a>.</li><li><em>T_arg2</em> Argument type used in the definition of <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a>.</li><li><em>T_arg3</em> Argument type used in the definition of <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a>.</li><li><em>T_accumulator</em> The accumulator type used for emission. The default <code>nil</code> means that no accumulator should be used, i.e. signal emission returns the return value of the last slot invoked.</li></ul>
<p>
You should use the more convenient unnumbered <a class="el" href="classsigc_1_1signal.html">sigc::signal</a> template. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="ce9f45a4ff22a06f3b8edb5a6c06a70b"></a><!-- doxytag: member="sigc::signal3::emitter_type" ref="ce9f45a4ff22a06f3b8edb5a6c06a70b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsigc_1_1internal_1_1signal__emit3.html">internal::signal_emit3</a>&lt;T_return, T_arg1,T_arg2,T_arg3, T_accumulator&gt; <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::<a class="el" href="structsigc_1_1internal_1_1signal__emit3.html">emitter_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="57c79755fc4c4b04196a9bf6742a0cc6"></a><!-- doxytag: member="sigc::signal3::result_type" ref="57c79755fc4c4b04196a9bf6742a0cc6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsigc_1_1internal_1_1signal__emit3.html#a3e7b467c2841d5110960382bb0deca3">emitter_type::result_type</a> <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal3.html#57c79755fc4c4b04196a9bf6742a0cc6">result_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="49c13da0a30318464062f5b26ff87979"></a><!-- doxytag: member="sigc::signal3::slot_type" ref="49c13da0a30318464062f5b26ff87979" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsigc_1_1slot.html">slot</a>&lt;T_return, T_arg1,T_arg2,T_arg3&gt; <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::<a class="el" href="classsigc_1_1slot.html">slot_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3bc0616e7ac933e702a889a2a84e92d4"></a><!-- doxytag: member="sigc::signal3::slot_list_type" ref="3bc0616e7ac933e702a889a2a84e92d4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsigc_1_1slot__list.html">slot_list</a>&lt;<a class="el" href="classsigc_1_1slot.html">slot_type</a>&gt; <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::<a class="el" href="structsigc_1_1slot__list.html">slot_list_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8029a48126a2018947a2b6680ddabe6b"></a><!-- doxytag: member="sigc::signal3::iterator" ref="8029a48126a2018947a2b6680ddabe6b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsigc_1_1slot__iterator.html">slot_list_type::iterator</a> <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::<a class="el" href="structsigc_1_1slot__iterator.html">iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="60e1ef95f82cd8981d61576d1e3f8e94"></a><!-- doxytag: member="sigc::signal3::const_iterator" ref="60e1ef95f82cd8981d61576d1e3f8e94" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsigc_1_1slot__const__iterator.html">slot_list_type::const_iterator</a> <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::<a class="el" href="structsigc_1_1slot__const__iterator.html">const_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cc453f0d5fc7f277494b2d6e737f6f68"></a><!-- doxytag: member="sigc::signal3::reverse_iterator" ref="cc453f0d5fc7f277494b2d6e737f6f68" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsigc_1_1slot__list.html#ddb44a7590825f917b3fcf0179fadadb">slot_list_type::reverse_iterator</a> <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal3.html#cc453f0d5fc7f277494b2d6e737f6f68">reverse_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4ba3eb58c4c5ac2c25f49c48fd0af264"></a><!-- doxytag: member="sigc::signal3::const_reverse_iterator" ref="4ba3eb58c4c5ac2c25f49c48fd0af264" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsigc_1_1slot__list.html#8293bfca54539958326f57375e4d8c14">slot_list_type::const_reverse_iterator</a> <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal3.html#4ba3eb58c4c5ac2c25f49c48fd0af264">const_reverse_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="52731959f272612fd6abfe8850c5c8cf"></a><!-- doxytag: member="sigc::signal3::signal3" ref="52731959f272612fd6abfe8850c5c8cf" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal3.html">signal3</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fe2c4320927b403b011a2538317e6c70"></a><!-- doxytag: member="sigc::signal3::signal3" ref="fe2c4320927b403b011a2538317e6c70" args="(const signal3 &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::<a class="el" href="classsigc_1_1signal3.html">signal3</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsigc_1_1signal3.html">signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3eae0b3796b2736be847f33a5124aacd"></a><!-- doxytag: member="sigc::signal3::connect" ref="3eae0b3796b2736be847f33a5124aacd" args="(const slot_type &amp;slot_)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1slot__iterator.html">iterator</a> <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsigc_1_1slot.html">slot_type</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>slot_</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a slot to the list of slots. 
<p>
Any functor or slot may be passed into <a class="el" href="classsigc_1_1signal3.html#3eae0b3796b2736be847f33a5124aacd">connect()</a>. It will be converted into a slot implicitely. The returned iterator may be stored for disconnection of the slot at some later point. It stays valid until the slot is removed from the list of slots. The iterator can also be implicitely converted into a <a class="el" href="structsigc_1_1connection.html">sigc::connection</a> object that may be used safely beyond the life time of the slot. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot_</em>&nbsp;</td><td>The slot to add to the list of slots. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator pointing to the new slot in the list. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e761fdcaa7de4d03db68dc6312b5ccdc"></a><!-- doxytag: member="sigc::signal3::emit" ref="e761fdcaa7de4d03db68dc6312b5ccdc" args="(typename type_trait&lt; T_arg1 &gt;::take _A_a1, typename type_trait&lt; T_arg2 &gt;::take _A_a2, typename type_trait&lt; T_arg3 &gt;::take _A_a3) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1signal3.html#57c79755fc4c4b04196a9bf6742a0cc6">result_type</a> <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::emit           </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take&nbsp;</td>
          <td class="paramname"> <em>_A_a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take&nbsp;</td>
          <td class="paramname"> <em>_A_a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg3&gt;::take&nbsp;</td>
          <td class="paramname"> <em>_A_a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Triggers the emission of the signal. 
<p>
During signal emission all slots that have been connected to the signal are invoked unless they are manually set into a blocking state. The parameters are passed on to the slots. If <em>T_accumulated</em> is not <code>nil</code>, an accumulator of this type is used to process the return values of the slot invocations. Otherwise, the return value of the last slot invoked is returned. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_A_a1</em>&nbsp;</td><td>Argument to be passed on to the slots. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_a2</em>&nbsp;</td><td>Argument to be passed on to the slots. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_A_a3</em>&nbsp;</td><td>Argument to be passed on to the slots. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The accumulated return values of the slot invocations. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cdf13dffd7d65b6000ef4003881e86dd"></a><!-- doxytag: member="sigc::signal3::emit_reverse" ref="cdf13dffd7d65b6000ef4003881e86dd" args="(typename type_trait&lt; T_arg1 &gt;::take _A_a1, typename type_trait&lt; T_arg2 &gt;::take _A_a2, typename type_trait&lt; T_arg3 &gt;::take _A_a3) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1signal3.html#57c79755fc4c4b04196a9bf6742a0cc6">result_type</a> <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::emit_reverse           </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take&nbsp;</td>
          <td class="paramname"> <em>_A_a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take&nbsp;</td>
          <td class="paramname"> <em>_A_a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg3&gt;::take&nbsp;</td>
          <td class="paramname"> <em>_A_a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Triggers the emission of the signal in reverse order (see <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a>). 
<p>

</div>
</div><p>
<a class="anchor" name="31e50c09c7227a8e5dc3cecb52de9631"></a><!-- doxytag: member="sigc::signal3::operator()" ref="31e50c09c7227a8e5dc3cecb52de9631" args="(typename type_trait&lt; T_arg1 &gt;::take _A_a1, typename type_trait&lt; T_arg2 &gt;::take _A_a2, typename type_trait&lt; T_arg3 &gt;::take _A_a3) const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1signal3.html#57c79755fc4c4b04196a9bf6742a0cc6">result_type</a> <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take&nbsp;</td>
          <td class="paramname"> <em>_A_a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take&nbsp;</td>
          <td class="paramname"> <em>_A_a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg3&gt;::take&nbsp;</td>
          <td class="paramname"> <em>_A_a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Triggers the emission of the signal (see <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a>). 
<p>

</div>
</div><p>
<a class="anchor" name="722230eba756857076043d3d4abebfc9"></a><!-- doxytag: member="sigc::signal3::make_slot" ref="722230eba756857076043d3d4abebfc9" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;<a class="el" href="classsigc_1_1signal3.html#57c79755fc4c4b04196a9bf6742a0cc6">result_type</a>, <a class="el" href="classsigc_1_1signal3.html">signal3</a>, typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg1&gt;::take,typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg2&gt;::take,typename <a class="el" href="structsigc_1_1type__trait.html">type_trait</a>&lt;T_arg3&gt;::take&gt; <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::make_slot           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a functor that calls <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a> on this signal. 
<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__mem__fun.html#g7d9ea809173f48bf5c76cf1989591602">sigc::mem_fun</a>(mysignal, &amp;<a class="code" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">sigc::signal3::emit</a>)
</pre></div> yields the same result. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A functor that calls <a class="el" href="classsigc_1_1signal3.html#e761fdcaa7de4d03db68dc6312b5ccdc">emit()</a> on this signal. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b9606b708078956a758b81503f956bee"></a><!-- doxytag: member="sigc::signal3::slots" ref="b9606b708078956a758b81503f956bee" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1slot__list.html">slot_list_type</a> <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::slots           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an STL-style interface for the signal's list of slots. 
<p>
This interface supports iteration, insertion and removal of slots. <dl class="return" compact><dt><b>Returns:</b></dt><dd>An STL-style interface for the signal's list of slots. </dd></dl>

</div>
</div><p>
<a class="anchor" name="742eb282312187bf8ee6992df1114781"></a><!-- doxytag: member="sigc::signal3::slots" ref="742eb282312187bf8ee6992df1114781" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return, class T_arg1, class T_arg2, class T_arg3, class T_accumulator = nil&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsigc_1_1slot__list.html">slot_list_type</a> <a class="el" href="classsigc_1_1signal3.html">sigc::signal3</a>&lt;T_return, T_arg1, T_arg2, T_arg3, T_accumulator&gt;::slots           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an STL-style interface for the signal's list of slots. 
<p>
This interface supports iteration, insertion and removal of slots. <dl class="return" compact><dt><b>Returns:</b></dt><dd>An STL-style interface for the signal's list of slots. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="signal_8h.html">signal.h</a></ul>
<hr><address><small>
Generated for libsigc++ 2.0 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.1 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
